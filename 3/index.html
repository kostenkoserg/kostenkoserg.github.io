<<!DOCTYPE html>
<html lang="en">
  <head>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-132824591-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-132824591-1');
</script>

    <meta charset="utf-8"/>
    <title>Sergii Kostenko's blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <!--link href="../css/prettify.css" rel="stylesheet"-->
    <link href="../css/prism.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <b><a class="navbar-brand" href="../index.html">Sergii Kostenko's Blog</a></b>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../about.html">About</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tags <b class="caret"></b></a>
              <ul class="dropdown-menu">
										<li><a href="../tags/wildfly.html">wildfly</a></li>
										<li><a href="../tags/logging.html">logging</a></li>
										<li><a href="../tags/jakartaee.html">jakartaee</a></li>
										<li><a href="../tags/resin.html">resin</a></li>
										<li><a href="../tags/performance.html">performance</a></li>
										<li><a href="../tags/infinispan.html">infinispan</a></li>
										<li><a href="../tags/gradle.html">gradle</a></li>
										<li><a href="../tags/ide.html">ide</a></li>
										<li><a href="../tags/cdi.html">cdi</a></li>
										<li><a href="../tags/batch.html">batch</a></li>
										<li><a href="../tags/ci.html">ci</a></li>
										<li><a href="../tags/openapi.html">openapi</a></li>
										<li><a href="../tags/microprofile.html">microprofile</a></li>
										<li><a href="../tags/oracle.html">oracle</a></li>
										<li><a href="../tags/jberet.html">jberet</a></li>
										<li><a href="../tags/github.html">github</a></li>
										<li><a href="../tags/activemq.html">activemq</a></li>
										<li><a href="../tags/jetty.html">jetty</a></li>
										<li><a href="../tags/api.html">api</a></li>
										<li><a href="../tags/jcache.html">jcache</a></li>
										<li><a href="../tags/jpa.html">jpa</a></li>
										<li><a href="../tags/jenkins.html">jenkins</a></li>
										<li><a href="../tags/json-b.html">json-b</a></li>
										<li><a href="../tags/linux.html">linux</a></li>
										<li><a href="../tags/jmx.html">jmx</a></li>
										<li><a href="../tags/vaadin.html">vaadin</a></li>
										<li><a href="../tags/java.html">java</a></li>
										<li><a href="../tags/security.html">security</a></li>
										<li><a href="../tags/jms.html">jms</a></li>
										<li><a href="../tags/jaxb.html">jaxb</a></li>
										<li><a href="../tags/sql.html">sql</a></li>
										<li><a href="../tags/swagger.html">swagger</a></li>
										<li><a href="../tags/hibernate.html">hibernate</a></li>
										<li><a href="../tags/quarkus.html">quarkus</a></li>
										<li><a href="../tags/jwt.html">jwt</a></li>
										<li><a href="../tags/rest-client.html">rest-client</a></li>
										<li><a href="../tags/tomcat.html">tomcat</a></li>
										<li><a href="../tags/jax-rs.html">jax-rs</a></li>
										<li><a href="../tags/jsr532.html">jsr532</a></li>
										<li><a href="../tags/jbake.html">jbake</a></li>
								</ul>
						</li>
          </ul>
					<!-- switch language -->
					<ul class="nav navbar-nav navbar-right">
						<li><a href="/">en</a></li>
						<li><a href="/ru">ru</a></li>
						<li><a  class="icon-rss" href="../feed.xml"></a></li>
					</ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">


				<a href="https://kostenko.org/blog/2020/03/data-processing-with-jakarta-ee-batch-api.html"><h1>Load huge amount of data with Jakarta EE Batch</h1></a>
				<p>25 March 2020</p>
  			<p><p>Processing huge amount of data is a challenge for every enterprise system. Jakarta EE specifications provides useful approach to get it done through <strong><a href="https://projects.eclipse.org/projects/ee4j.batch">Jakarta Batch</a></strong> (JSR-352):</p>
<blockquote>
<p>Batch processing is a pervasive workload pattern, expressed by a distinct application organization and execution model. It is found across virtually every industry, applied to such tasks as statement generation, bank postings, risk evaluation, credit score calculation, inventory management, portfolio optimization, and on and on. Nearly any bulk processing task from any business sector is a candidate for batch processing.<br />
Batch processing is typified by bulk-oriented, non-interactive, background execution. Frequently long-running, it may be data or computationally intensive, execute sequentially or in parallel, and may be initiated through various invocation models, including ad hoc, scheduled, and on-demand.<br />
Batch applications have common requirements, including logging, checkpointing, and parallelization. Batch workloads have common requirements, especially operational control, which allow for initiation of, and interaction with, batch instances; such interactions include stop and restart.</p>
</blockquote>
<p>One of the typical use case is a import data from different sources and formats to internal database. Below we will design sample application to import data, for example, from  <code>json</code> and <code>xml</code> files to the database and see how well structured it can be.</p>
<p>Using <strong>Eclipse Red Hat CodeReady Studio plugin</strong>, we can easily design our solution diagram:<br />
<img src="/img/2020-02-jakarta-batch-import.png" alt="import batch diagram" /></p>
<p>Jakarta Batch descriptor in this case will looks like:<br />
<code>META-INF/batch-jobs/hugeImport.xml:</code></p>
<pre><code class="language-java">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;job id=&quot;hugeImport&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/jobXML_1_0.xsd&quot; version=&quot;1.0&quot;&gt;
    &lt;step id=&quot;fileSelector&quot; next=&quot;decider&quot;&gt;
        &lt;batchlet ref=&quot;fileSelectorBatchlet&quot;&gt;
            &lt;properties&gt;
                &lt;property name=&quot;path&quot; value=&quot;/tmp/files2import&quot;/&gt;
            &lt;/properties&gt;
        &lt;/batchlet&gt;
    &lt;/step&gt;
    &lt;decision id=&quot;decider&quot; ref=&quot;myDecider&quot;&gt;
        &lt;next on=&quot;xml&quot; to=&quot;xmlParser&quot;/&gt;
        &lt;next on=&quot;json&quot; to=&quot;jsonParser&quot;/&gt;
    &lt;/decision&gt;
    &lt;step id=&quot;xmlParser&quot; next=&quot;chunkProcessor&quot;&gt;
        &lt;batchlet ref=&quot;xmlParserBatchlet&quot;/&gt;
    &lt;/step&gt;
    &lt;step id=&quot;jsonParser&quot; next=&quot;chunkProcessor&quot;&gt;
        &lt;batchlet ref=&quot;jsonParserBatchlet&quot;/&gt;
    &lt;/step&gt;
    &lt;step id=&quot;chunkProcessor&quot;&gt;
        &lt;chunk&gt;
            &lt;reader ref=&quot;itemReader&quot;/&gt;
            &lt;processor ref=&quot;itemMockProcessor&quot;/&gt;
            &lt;writer ref=&quot;itemJpaWriter&quot;/&gt;
        &lt;/chunk&gt;
        &lt;partition&gt;
            &lt;plan partitions=&quot;5&quot;&gt;&lt;/plan&gt;
        &lt;/partition&gt;
    &lt;/step&gt;
&lt;/job&gt;
</code></pre>
<p>So, now we need to implement each brick above and try to keep each batchlet independent as much as possible. As you can see from above our sample job consist from:</p>
<ul>
<li><strong>fileSelector</strong> - batchlet do file selection based on supported by configuration file extension</li>
<li><strong>decider</strong> - decision maker, responsible for choosing right parser</li>
<li><strong>xml\jsonParser</strong> - parser batchlets, responsible for file parsing to a list of items</li>
<li><strong>chunkProcessor</strong> - items processing chunk(<strong>reader</strong>, optional <strong>processor</strong> and <strong>writer</strong>) with partitioning to boost performance</li>
</ul>
<p>Before start with implementation, let's design useful solution to <strong>share state between steps</strong>. Unfortunately, Jakarta Batch Specification does not provide job scoped CDI beans yet (JBeret implementation does, specification doesn't). But we able to use <strong><code>JobContext.set\getTransientUserData()</code></strong> to deal with the current batch context. In our case we want to share <code>File</code> and <code>Queue</code> with  items for processing:</p>
<pre><code class="language-java">@Named
public class ImportJobContext {
    @Inject
    private JobContext jobContext;

    private Optional&lt;File&gt; file = Optional.empty();
    private Queue&lt;ImportItem&gt; items = new ConcurrentLinkedQueue&lt;&gt;();

    public Optional&lt;File&gt; getFile() {
        return getImportJobContext().file;
    }
    public void setFile(Optional&lt;File&gt; file) {
        getImportJobContext().file = file;
    }
    public Queue&lt;ImportItem&gt; getItems() {
        return getImportJobContext().items;
    }

    private ImportJobContext getImportJobContext() {
        if (jobContext.getTransientUserData() == null) {
            jobContext.setTransientUserData(this);
        }
        return (ImportJobContext) jobContext.getTransientUserData();
    }
}
</code></pre>
<p>Now we can inject our custom <strong><code>ImportJobContext</code></strong> to share type-safe state between batchlets. First step is search file for processing by provided in step properties path:</p>
<pre><code class="language-java">@Named
public class FileSelectorBatchlet extends AbstractBatchlet {

    @Inject
    private ImportJobContext jobContext;

    @Inject
    @BatchProperty
    private String path;

    @Override
    public String process() throws Exception {
        Optional&lt;File&gt; file = Files.walk(Paths.get(path)).filter(Files::isRegularFile).map(Path::toFile).findAny();
        if (file.isPresent()) {
            jobContext.setFile(file);
        }
        return BatchStatus.COMPLETED.name();
    }
}
</code></pre>
<p>After we need to make decision about parser, for example, based on extension. Decider just returns file extension as string and then  <strong>batch runtime</strong>  should give control to the corresponding parser batchlet. Please, check <code>&lt;decision id=&quot;decider&quot; ref=&quot;myDecider&quot;&gt;</code> section in the XML batch descriptor above.</p>
<pre><code class="language-java">@Named
public class MyDecider implements Decider {

    @Inject
    private ImportJobContext jobContext;

    @Override
    public String decide(StepExecution[] ses) throws Exception {
        if (!jobContext.getFile().isPresent()) {
            throw new FileNotFoundException();
        }
        String name = jobContext.getFile().get().getName();
        String extension = name.substring(name.lastIndexOf(&quot;.&quot;)+1);
        return extension;
    }
}
</code></pre>
<p>ParserBatchlet in turn should parse file using <strong>JSON-B</strong> or <strong>JAXB</strong> depends on type and fill Queue with <strong><code>ImportItem</code></strong> objects. I would like to use <strong><code>ConcurrentLinkedQueue</code></strong> to share items between partitions, but if you need for some other behavior here, you can provide <strong><code>javax.batch.api.partition.PartitionMapper</code></strong> with your own implementation</p>
<pre><code class="language-java">@Named
public class JsonParserBatchlet  extends AbstractBatchlet {

    @Inject
    ImportJobContext importJobContext;

    @Override
    public String process() throws Exception {

        List&lt;ImportItem&gt; items = JsonbBuilder.create().fromJson(
                new FileInputStream(importJobContext.getFile().get()),
                new ArrayList&lt;ImportItem&gt;(){}.getClass().getGenericSuperclass());

        importJobContext.getItems().addAll(items);
        return BatchStatus.COMPLETED.name();
    }
}
</code></pre>
<p>ItemReader then will looks as simple as possible, just pool item from the Queue:</p>
<pre><code class="language-java">@Named
public class ItemReader  extends AbstractItemReader {

    @Inject
    ImportJobContext importJobContext;

    @Override
    public ImportItem readItem() throws Exception {

        return importJobContext.getItems().poll();
    }
}
</code></pre>
<p>And persist time...</p>
<pre><code class="language-java">@Named
public class ItemJpaWriter  extends AbstractItemWriter  {

    @PersistenceContext
    EntityManager entityManager;

    @Override
    public void writeItems(List&lt;Object&gt; list) throws Exception {
        for (Object obj : list) {
            ImportItem item = (ImportItem) obj;
            entityManager.merge(item);
        }
    }
}
</code></pre>
<p>Actually, this is it! Now we able to easily extend our application with new parsers, processors and writers without any existing code changes,  - just describe new (update existing) flows over Jakarta Batch descriptor.<br />
Of course, <strong>Jakarta Batch specification</strong> provides much more helpful functionality than i have covered in this post (<strong>Checkpoints</strong>, <strong>Exception Handling</strong>, <strong>Listeners</strong>, <strong>Flow Control</strong>, <strong>Failed job restarting</strong> etc.), but even it enough to see how simple, power and well structured it can be.</p>
<p><strong>Note!</strong> <strong>Wildfly Application Server</strong> implements Jakarta Batch specification through the <strong>batch-jberet subsystem</strong>. By default last one configured to use only <strong>10</strong> threads.</p>
<pre><code class="language-xml">&lt;subsystem xmlns=&quot;urn:jboss:domain:batch-jberet:2.0&quot;&gt;
    ...
    &lt;thread-pool name=&quot;batch&quot;&gt;
        &lt;max-threads count=&quot;10&quot;/&gt;
        &lt;keepalive-time time=&quot;30&quot; unit=&quot;seconds&quot;/&gt;
    &lt;/thread-pool&gt;
&lt;/subsystem&gt;
</code></pre>
<p>So, if you are planing intensive usage of <strong>Batch runtime</strong> - feel free to increase this parameter:</p>
<pre><code class="language-bash">/subsystem=batch-jberet/thread-pool=batch/:write-attribute(name=max-threads, value=100)
</code></pre>
<p>Described sample application source code available on <a href="https://github.com/kostenkoserg/ee-batch-processing-examples">GitHub</a></p>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/03/data-processing-with-jakarta-ee-batch-api.html#disqus_thread" data-disqus-identifier="blog/2020/03/data-processing-with-jakarta-ee-batch-api.html">Comments</a></p>
				<hr/>
				<a href="https://kostenko.org/blog/2020/03/jpa-wildfly-slow-sql.html"><h1>Slow SQL logging with JPA and Wildfly</h1></a>
				<p>20 March 2020</p>
  			<p><p>Recently I wrote about <strong><a href="https://kostenko.org/blog/2020/01/sql-spying-with-wildfly.html">Logging for JPA SQL queries with Wildfly</a></strong>. In this post I'll show you how to configure <strong>logging for slow SQL queries</strong>.</p>
<p>Wildfly uses Hibernate as JPA provider. So, to enable <strong>slow sql feature</strong> you just need to provide <code>hibernate.session.events.log.LOG_QUERIES_SLOWER_THAN_MS</code> property in your <strong>persistence.xml</strong> :</p>
<pre><code class="language-java">&lt;properties&gt;
    ...
    &lt;property name=&quot;hibernate.session.events.log.LOG_QUERIES_SLOWER_THAN_MS&quot; value=&quot;25&quot;/&gt;
    ...
&lt;/properties&gt;    
</code></pre>
<p>To log slow queries to separate file, please configure logging like:</p>
<pre><code class="language-bash">/subsystem=logging/periodic-rotating-file-handler=slow_sql_handler:add(level=INFO, file={&quot;path&quot;=&gt;&quot;slowsql.log&quot;}, append=true, autoflush=true, suffix=.yyyy-MM-dd,formatter=&quot;%d{yyyy-MM-dd HH:mm:ss,SSS}&quot;)
/subsystem=logging/logger=org.hibernate.SQL_SLOW:add(use-parent-handlers=false,handlers=[&quot;slow_sql_handler&quot;])
</code></pre>
<p><strong>Note!</strong><br />
Described above functionality available since Hibernate version <strong>5.4.5</strong>, but latest for today <strong>Wildfly 19</strong> uses Hibernate version <strong>5.3</strong>.  Fortunately, if you can't wait to enjoy the latest version of Hibernate, you can use <strong><a href="https://docs.jboss.org/hibernate/orm/5.4/topical/html_single/wildfly/Wildfly.html">WildFly feature packs</a></strong> to create a <strong>custom server</strong> with a different version of Hibernate ORM in few simple steps:</p>
<p>Create provisioning configuration file (provision.xml)</p>
<pre><code class="language-xml">&lt;server-provisioning xmlns=&quot;urn:wildfly:server-provisioning:1.1&quot; copy-module-artifacts=&quot;true&quot;&gt;
    &lt;feature-packs&gt;
	&lt;feature-pack
		groupId=&quot;org.hibernate&quot;
		artifactId=&quot;hibernate-orm-jbossmodules&quot;
		version=&quot;${hibernate-orm.version}&quot; /&gt;
	&lt;feature-pack
		groupId=&quot;org.wildfly&quot;
		artifactId=&quot;wildfly-feature-pack&quot;
		version=&quot;${wildfly.version}&quot; /&gt;
    &lt;/feature-packs&gt;
&lt;/server-provisioning&gt;
</code></pre>
<p>Create gradle build file (build.gradle)</p>
<pre><code class="language-java">plugins {
  id &quot;org.wildfly.build.provision&quot; version '0.0.6'
}
repositories {
    mavenLocal()
    mavenCentral()
    maven {
        name 'jboss-public'
        url 'https://repository.jboss.org/nexus/content/groups/public/'
    }
}
provision {
    //Optional destination directory:
    destinationDir = file(&quot;wildfly-custom&quot;)

    //Update the JPA API:
    override( 'org.hibernate.javax.persistence:hibernate-jpa-2.1-api' ) {
        groupId = 'javax.persistence'
        artifactId = 'javax.persistence-api'
        version = '2.2'
    }
    configuration = file( 'provision.xml' )
    //Define variables which need replacing in the provisioning configuration!
    variables['wildfly.version'] = '17.0.0.Final'
    variables['hibernate-orm.version'] = '5.4.5.Final'
}
</code></pre>
<p>Build custom Wildfly version</p>
<pre><code class="language-bash">gradle provision
</code></pre>
<p>Switch to a different Hibernate ORM slot in your persistence.xml</p>
<pre><code class="language-java">&lt;properties&gt;
    &lt;property name=&quot;jboss.as.jpa.providerModule&quot; value=&quot;org.hibernate:5.4&quot;/&gt;
&lt;/properties&gt;
</code></pre>
<p>Enjoy!</p>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/03/jpa-wildfly-slow-sql.html#disqus_thread" data-disqus-identifier="blog/2020/03/jpa-wildfly-slow-sql.html">Comments</a></p>
				<hr/>
				<a href="https://kostenko.org/blog/2020/03/firebase-push-microprofile-rest-client.html"><h1>Firebase push notifications with Eclipse Microprofile Rest Client</h1></a>
				<p>05 March 2020</p>
  			<p><p>Nowadays <strong>Push notifications</strong> is a must have feature for any trend application. Firebase Cloud Messaging (<strong>FCM</strong>) is a free (at least in this moment) cross-platform solution for messages and notifications for <strong>Android</strong>, <strong>iOS</strong> and <strong>Web applications</strong>.</p>
<p><img src="/img/2020-03-firebase-mp-rest-client.png" alt="firebase, push, microprofile, rest client" /></p>
<p>To enable push notification on client side you should create Firebase project and follow the <a href="https://firebase.google.com/docs/cloud-messaging">manual</a> or  <a href="https://github.com/firebase/quickstart-js/tree/master/messaging">examples</a>. From the server side perspective all you need to send push notification is:</p>
<ul>
<li><strong>Server key</strong> - will be created for your firebase project</li>
<li><strong>Instance ID token</strong> - id of specific subscribed instance (instance destination id)</li>
</ul>
<p>Firebase provides <strong><code>https://fcm.googleapis.com/fcm/send</code></strong> endpoint and very simple <a href="https://firebase.google.com/docs/cloud-messaging/http-server-ref">HTTP API</a> like</p>
<pre><code class="language-java">{
    &quot;to&quot;: &quot;&lt;Instance ID token&gt;&quot;,
    &quot;notification&quot;: {
      &quot;title&quot;: &quot;THIS IS MP REST CLIENT!&quot;,
      &quot;body&quot;: &quot;The quick brown fox jumps over the lazy dog.&quot;
      }
}
</code></pre>
<p>So, let's design simple Microprofile REST client to deal with above:</p>
<pre><code class="language-java">@Path(&quot;/&quot;)
@RegisterRestClient(configKey = &quot;push-api&quot;)
public interface PushClientService {

    @POST
    @Path(&quot;/fcm/send&quot;)
    @Produces(&quot;application/json&quot;)
    @ClientHeaderParam(name = &quot;Authorization&quot;, value = &quot;{generateAuthHeader}&quot;)
    void send(PushMessage msg);

    default String generateAuthHeader() {
        return &quot;key=&quot; + ConfigProvider.getConfig().getValue(&quot;firebase.server_key&quot;, String.class);
    }
}
</code></pre>
<pre><code class="language-java">public class PushMessage {

    public String to;
    public PushNotification notification;

    public static class PushNotification {
        public String title;
        public String body;
    }
}
</code></pre>
<p>and application.properties</p>
<pre><code class="language-bash"># firebase server key
firebase.server_key=&lt;SERVER_KEY&gt;
# rest client
push-api/mp-rest/url=https://fcm.googleapis.com/
</code></pre>
<p>Actually, this is it! Now you able to <code>@Inject</code>  PushClientService and enjoy push notifications as well.</p>
<pre><code class="language-java">@Inject
@RestClient
PushClientService pushService;
...
pushService.send(message);
</code></pre>
<p>If you would like to test how it works from client side perspective, - feel free to use <strong><a href="https://kostenko.org/blog/2020/03/firebase-push-microprofile-rest-client/index.htm">Test web application</a></strong> to generate instance ID token and check notifications delivery.</p>
<p>Described sample application source code with swagger-ui endpoint and firebase.server_key available on <a href="https://github.com/kostenkoserg/microprofile-quarkus-example">GitHub</a></p>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/03/firebase-push-microprofile-rest-client.html#disqus_thread" data-disqus-identifier="blog/2020/03/firebase-push-microprofile-rest-client.html">Comments</a></p>
				<hr/>
				<a href="https://kostenko.org/blog/2020/02/jwt-openapi-microprofile-quarkus.html"><h1>Well secured and documented REST API with Eclipse Microprofile and Quarkus</h1></a>
				<p>20 February 2020</p>
  			<p><p>Eclipse Microprofile specification provides several many helpful sections about building well designed microservice-oriented applications. <strong>OpenAPI</strong>, <strong>JWT Propagation</strong> and <strong>JAX-RS</strong> - the ones of them.<br />
<img src="/img/2020-02-jwt-openapi-jaxrs-microprofile.png" alt="microprofile, jwt, openapi, jax-rs" /><br />
To see how it works on practice let's design two typical REST resources: insecured <strong>token</strong> to generate JWT and secured  <strong>user</strong>, based on Quarkus Microprofile implementation.</p>
<p>Easiest way to bootstrap Quarkus application from scratch is generation project structure by provided starter page - <strong><a href="https://code.quarkus.io/">code.quarkus.io</a></strong>. Just select build tool you like and extensions you need. In our case it is:</p>
<ul>
<li><strong>SmallRye JWT</strong></li>
<li><strong>SmallRye OpenAPI</strong></li>
</ul>
<p>I prefer <strong>gradle</strong>, - and my <code>build.gradle</code> looks pretty simple</p>
<pre><code class="language-java">group 'org.kostenko'
version '1.0.0'
plugins {
    id 'java'
    id 'io.quarkus'
}
repositories {
     mavenLocal()
     mavenCentral()
}
dependencies {
    implementation 'io.quarkus:quarkus-smallrye-jwt'
    implementation 'io.quarkus:quarkus-smallrye-openapi'
    implementation 'io.quarkus:quarkus-resteasy-jackson'    
    implementation 'io.quarkus:quarkus-resteasy'
    implementation enforcedPlatform(&quot;${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}&quot;)
    testImplementation 'io.quarkus:quarkus-junit5'
    testImplementation 'io.rest-assured:rest-assured'
}
compileJava {
    options.compilerArgs &lt;&lt; '-parameters'
}
</code></pre>
<p>Now we are ready to improve standard <strong>JAX-RS</strong> service with <strong>OpenAPI</strong> and <strong>JWT</strong> stuff:</p>
<pre><code class="language-java">@RequestScoped
@Path(&quot;/user&quot;)
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Tags(value = @Tag(name = &quot;user&quot;, description = &quot;All the user methods&quot;))
@SecurityScheme(securitySchemeName = &quot;jwt&quot;, type = SecuritySchemeType.HTTP, scheme = &quot;bearer&quot;, bearerFormat = &quot;jwt&quot;)
public class UserResource {

    @Inject
    @Claim(&quot;user_name&quot;)
    Optional&lt;JsonString&gt; userName;

    @POST
    @PermitAll
    @Path(&quot;/token/{userName}&quot;)
    @APIResponses(value = {
        @APIResponse(responseCode = &quot;400&quot;, description = &quot;JWT generation error&quot;),
        @APIResponse(responseCode = &quot;200&quot;, description = &quot;JWT successfuly created.&quot;, content = @Content(schema = @Schema(implementation = User.class)))})
    @Operation(summary = &quot;Create JWT token by provided user name&quot;)
    public User getToken(@PathParam(&quot;userName&quot;) String userName) {
        User user = new User();
        user.setJwt(TokenUtils.generateJWT(userName));
        return user;    
    }

    @GET
    @RolesAllowed(&quot;user&quot;)
    @Path(&quot;/current&quot;)
    @SecurityRequirement(name = &quot;jwt&quot;, scopes = {})
    @APIResponses(value = {
        @APIResponse(responseCode = &quot;401&quot;, description = &quot;Unauthorized Error&quot;),
        @APIResponse(responseCode = &quot;200&quot;, description = &quot;Return user data&quot;, content = @Content(schema = @Schema(implementation = User.class)))})
    @Operation(summary = &quot;Return user data by provided JWT token&quot;)
    public User getUser() {
        User user = new User();
        user.setName(userName.get().toString());
        return user;
    }
}
</code></pre>
<p>First let's take a brief review of used <strong><a href="https://github.com/eclipse/microprofile-open-api">Open API</a></strong> annotations:</p>
<ul>
<li><code>@Tags(value = @Tag(name = &quot;user&quot;, description = &quot;All the user methods&quot;))</code> -  Represents a tag. Tag is a meta-information you can use to help organize your API end-points.</li>
<li><code>@SecurityScheme(securitySchemeName = &quot;jwt&quot;, type = SecuritySchemeType.HTTP, scheme = &quot;bearer&quot;, bearerFormat = &quot;jwt&quot;)</code> - Defines a security scheme that can be used by the operations.</li>
<li><code>@APIResponse(responseCode = &quot;401&quot;, description = &quot;Unauthorized Error&quot;)</code> - Corresponds to the OpenAPI response model object which  describes a single response from an API Operation.</li>
<li><code>@Operation(summary = &quot;Return user data by provided JWT token&quot;)</code> - Describes an operation or typically a HTTP method against a specific path.</li>
<li><code>@Schema(implementation = User.class)</code> - Allows the definition of input and output data types.</li>
</ul>
<p>To more details about Open API annotations, please refer to the <strong><a href="https://github.com/eclipse/microprofile-open-api/blob/master/spec/src/main/asciidoc/microprofile-openapi-spec.adoc">MicroProfile OpenAPI Specification</a></strong>.</p>
<p>After start the application, you will able to get your Open API description in the  <strong>.yaml</strong> format by the next URL <a href="http://0.0.0.0:8080/openapi">http://0.0.0.0:8080/openapi</a> or even enjoy <strong>Swagger UI</strong> as well by <a href="http://0.0.0.0:8080/swagger-ui/">http://0.0.0.0:8080/swagger-ui/</a> :<br />
<img src="/img/2020-02-swagger-ui.png" alt="microprofile, openapi, swagger-ui" /></p>
<p><strong>Note</strong> By default swagger-ui available in the dev mode only. If you would like to keep swagger on production, - add next property to your <code>application.properties</code></p>
<pre><code class="language-java">quarkus.swagger-ui.always-include=true
</code></pre>
<p>Second part of this post is a <strong><a href="https://github.com/eclipse/microprofile-jwt-auth">JWT role based access control(RBAC)</a></strong> for microservice endpoints. JSON Web Tokens are an open, industry standard  <a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a> method for representing claims securely between two parties and below we will see how easy it can be integrated in your application with Eclipse Microprofile.</p>
<p>As JWT suggests usage of cryptography - we need to generate public\private key pair before start coding:</p>
<pre><code class="language-bash"># Generate a private key
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048

# Derive the public key from the private key
openssl rsa -pubout -in private_key.pem -out public_key.pem
</code></pre>
<p>Now we are able to generate JWT and sign data with our private key in the, for example, next way:</p>
<pre><code class="language-java">public static String generateJWT(String userName) throws Exception {

    Map&lt;String, Object&gt; claimMap = new HashMap&lt;&gt;();
    claimMap.put(&quot;iss&quot;, &quot;https://kostenko.org&quot;);
    claimMap.put(&quot;sub&quot;, &quot;jwt-rbac&quot;);
    claimMap.put(&quot;exp&quot;, currentTimeInSecs + 300)
    claimMap.put(&quot;iat&quot;, currentTimeInSecs);
    claimMap.put(&quot;auth_time&quot;, currentTimeInSecs);
    claimMap.put(&quot;jti&quot;, UUID.randomUUID().toString());
    claimMap.put(&quot;upn&quot;, &quot;UPN&quot;);
    claimMap.put(&quot;groups&quot;, Arrays.asList(&quot;user&quot;));
    claimMap.put(&quot;raw_token&quot;, UUID.randomUUID().toString());
    claimMap.put(&quot;user_bane&quot;, userName);

    return Jwt.claims(claimMap).jws().signatureKeyId(&quot;META-INF/private_key.pem&quot;).sign(readPrivateKey(&quot;META-INF/private_key.pem&quot;));
}
</code></pre>
<p>For additional information about JWT structure, please refer <strong><a href="https://jwt.io/introduction/">https://jwt.io</a></strong></p>
<p>Time to review our application security stuff:<br />
<code>@RequestScoped</code> -  It is not about security as well. But as JWT is request scoped we need this one to work correctly;<br />
<code>@PermitAll</code> - Specifies that all security roles are allowed to invoke the specified method;<br />
<code>@RolesAllowed(&quot;user&quot;)</code> - Specifies the list of roles permitted to access method;<br />
<code>@Claim(&quot;user_name&quot;)</code> - Allows us inject provided by JWT field;</p>
<p>To configure JWT in your <code>application.properties</code>, please add</p>
<pre><code class="language-bash">quarkus.smallrye-jwt.enabled=true
mp.jwt.verify.publickey.location=META-INF/public_key.pem
mp.jwt.verify.issuer=https://kostenko.org

# quarkus.log.console.enable=true
# quarkus.log.category.&quot;io.quarkus.smallrye.jwt&quot;.level=TRACE
# quarkus.log.category.&quot;io.undertow.request.security&quot;.level=TRACE
</code></pre>
<p>And actually that is it, - if you try to reach <code>/user/current</code> service without or with bad JWT token in the <code>Authorization</code> header - you will get  <strong>HTTP 401 Unauthorized</strong> error.</p>
<p>curl example:</p>
<pre><code class="language-java">curl -X GET &quot;http://localhost:8080/user/current&quot; -H &quot;accept: application/json&quot; -H &quot;Authorization: Bearer eyJraWQiOiJNRVRBLUlORi9wcml2YXRlX2tleS5wZW0iLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJqd3QtcmJhYyIsInVwbiI6IlVQTiIsInJhd190b2tlbiI6IjQwOWY3MzVkLTQyMmItNDI2NC1iN2UyLTc1YTk0OGFjMTg3MyIsInVzZXJfbmFtZSI6InNlcmdpaSIsImF1dGhfdGltZSI6MTU4MjE5NzM5OSwiaXNzIjoiaHR0cHM6Ly9rb3N0ZW5rby5vcmciLCJncm91cHMiOlsidXNlciJdLCJleHAiOjkyMjMzNzIwMzY4NTQ3NzU4MDcsImlhdCI6MTU4MjE5NzM5OSwianRpIjoiMzNlMGMwZjItMmU0Yi00YTczLWJkNDItNDAzNWQ4NTYzODdlIn0.QteseKKwnYJWyj8ccbI1FuHBgWOk98PJuN0LU1vnYO69SYiuPF0d9VFbBada46N_kXIgzw7btIc4zvHKXVXL5Uh3IO2v1lnw0I_2Seov1hXnzvB89SAcFr61XCtE-w4hYWAOaWlkdTAmpMSUt9wHtjc0MwvI_qSBD3ol_VEoPv5l3_W2NJ2YBnqkY8w68c8txL1TnoJOMtJWB-Rpzy0XrtiO7HltFAz-Gm3spMlB3FEjnmj8-LvMmoZ3CKIybKO0U-bajWLPZ6JMJYtp3HdlpsiXNmv5QdIq1yY7uOPIKDNnPohWCgOhFVW-bVv9m-LErc_s45bIB9djwe13jFTbNg&quot;
</code></pre>
<p>Source code of described sample application available on <a href="https://github.com/kostenkoserg/microprofile-quarkus-example">GitHub</a></p>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/02/jwt-openapi-microprofile-quarkus.html#disqus_thread" data-disqus-identifier="blog/2020/02/jwt-openapi-microprofile-quarkus.html">Comments</a></p>
				<hr/>
				<a href="https://kostenko.org/blog/2020/02/jpa-relation-mappings.html"><h1>Simple note about using JPA relation  mappings</h1></a>
				<p>14 February 2020</p>
  			<p><p>There is a lot of typical examples how to build JPA <code>@OneToMany</code> and <code>@ManyToOne</code> relationships in your Jakarta EE application. And usually it looks like:</p>
<pre><code class="language-java">@Entity
@Table(name = &quot;author&quot;)
public class Author {
    @OneToMany
    private List&lt;Book&gt; book;
    ...
}
</code></pre>
<pre><code class="language-java">@Entity
@Table(name = &quot;book&quot;)
public class Book {
    @ManyToOne
    private Author author;
    ...
}
</code></pre>
<p>This code looks pretty clear, but on my opinion <strong>you should NOT USE this style</strong> in your real world application. From years of JPA using experience i definitely can say that sooner or later your project will stuck with known performance issues and holy war questions about: <strong>N+1</strong>, <strong>LazyInitializationException</strong>, <strong>Unidirectional @OneToMany</strong> , <strong>CascadeTypes</strong> ,<strong>LAZY vs EAGER</strong>, <strong>JOIN FETCH</strong>, <strong>Entity Graph</strong>, <strong>Fetching lot of unneeded data</strong>, <strong>Extra queries (for example: select Author by id before persist Book)</strong> etcetera.  Even if you are have answers for each potential issue above, usually proposed solution will add unreasonable complexity to the project.</p>
<p>To avoid potential issues i recommend to follow next rules:</p>
<ul>
<li>Avoid using of <code>@OneToMany</code> at all</li>
<li>Use <code>@ManyToOne</code> to build constrains but work with  <strong>ID</strong> instead of Entity</li>
</ul>
<p>Unfortunately, simple snippet below does not work as expected in case <code>persist</code></p>
<pre><code class="language-java">@ManyToOne(targetEntity = Author.class)
private long authorId;
</code></pre>
<p>But,we can use next one instead of</p>
<pre><code class="language-java">@JoinColumn(name = &quot;authorId&quot;, insertable = false, updatable = false)
@ManyToOne(targetEntity = Author.class)
private Author author;

private long authorId;

public long getAuthorId() {
    return authorId;
}

public void setAuthorId(long authorId) {
    this.authorId = authorId;
}
</code></pre>
<p>Hope, this two simple rules helps you enjoy all power of JPA with KISS and decreasing count of complexity.</p>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/02/jpa-relation-mappings.html#disqus_thread" data-disqus-identifier="blog/2020/02/jpa-relation-mappings.html">Comments</a></p>
				<hr/>

		<ul class="pager">
				<li class="previous"><a href="https://kostenko.org/2">Previous</a></li>
			<li">Page: 3/11 (<a href="../archive.html">archive</a>)</li>
				<li class="next"><a href="https://kostenko.org/4">Next</a></li>
		</ul>
		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2019 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.6.4</a></p>
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <!--script src="../js/prettify.js"></script-->
		<script src="../js/prism.js"></script>

		<script id="dsq-count-scr" src="//kostenko-org.disqus.com/count.js" async></script>
  </body>
</html>
