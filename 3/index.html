<<!DOCTYPE html>
<html lang="en">
  <head>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-132824591-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-132824591-1');
</script>

    <meta charset="utf-8"/>
    <title>Sergii Kostenko's blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/asciidoctor.css" rel="stylesheet">
    <link href="../css/base.css" rel="stylesheet">
    <!--link href="../css/prettify.css" rel="stylesheet"-->
    <link href="../css/prism.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->

    <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../favicon.ico">
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <b><a class="navbar-brand" href="../index.html">Sergii Kostenko's Blog</a></b>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../about.html">About</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Tags <b class="caret"></b></a>
              <ul class="dropdown-menu">
										<li><a href="../tags/wildfly.html">wildfly</a></li>
										<li><a href="../tags/logging.html">logging</a></li>
										<li><a href="../tags/jakartaee.html">jakartaee</a></li>
										<li><a href="../tags/resin.html">resin</a></li>
										<li><a href="../tags/performance.html">performance</a></li>
										<li><a href="../tags/infinispan.html">infinispan</a></li>
										<li><a href="../tags/gradle.html">gradle</a></li>
										<li><a href="../tags/ide.html">ide</a></li>
										<li><a href="../tags/cdi.html">cdi</a></li>
										<li><a href="../tags/batch.html">batch</a></li>
										<li><a href="../tags/ci.html">ci</a></li>
										<li><a href="../tags/openapi.html">openapi</a></li>
										<li><a href="../tags/microprofile.html">microprofile</a></li>
										<li><a href="../tags/jberet.html">jberet</a></li>
										<li><a href="../tags/github.html">github</a></li>
										<li><a href="../tags/activemq.html">activemq</a></li>
										<li><a href="../tags/jetty.html">jetty</a></li>
										<li><a href="../tags/api.html">api</a></li>
										<li><a href="../tags/jcache.html">jcache</a></li>
										<li><a href="../tags/jpa.html">jpa</a></li>
										<li><a href="../tags/jenkins.html">jenkins</a></li>
										<li><a href="../tags/json-b.html">json-b</a></li>
										<li><a href="../tags/linux.html">linux</a></li>
										<li><a href="../tags/jmx.html">jmx</a></li>
										<li><a href="../tags/vaadin.html">vaadin</a></li>
										<li><a href="../tags/java.html">java</a></li>
										<li><a href="../tags/security.html">security</a></li>
										<li><a href="../tags/jms.html">jms</a></li>
										<li><a href="../tags/jaxb.html">jaxb</a></li>
										<li><a href="../tags/sql.html">sql</a></li>
										<li><a href="../tags/swagger.html">swagger</a></li>
										<li><a href="../tags/hibernate.html">hibernate</a></li>
										<li><a href="../tags/quarkus.html">quarkus</a></li>
										<li><a href="../tags/jwt.html">jwt</a></li>
										<li><a href="../tags/rest-client.html">rest-client</a></li>
										<li><a href="../tags/tomcat.html">tomcat</a></li>
										<li><a href="../tags/jax-rs.html">jax-rs</a></li>
										<li><a href="../tags/jsr532.html">jsr532</a></li>
										<li><a href="../tags/jbake.html">jbake</a></li>
								</ul>
						</li>
          </ul>
					<!-- switch language -->
					<ul class="nav navbar-nav navbar-right">
						<li><a href="/">en</a></li>
						<li><a href="/ru">ru</a></li>
						<li><a  class="icon-rss" href="../feed.xml"></a></li>
					</ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>
    <div class="container">


				<a href="https://kostenko.org/blog/2020/03/firebase-push-microprofile-rest-client.html"><h1>Firebase push notifications with Eclipse Microprofile Rest Client</h1></a>
				<p>05 March 2020</p>
  			<p><p>Nowadays <strong>Push notifications</strong> is a must have feature for any trend application. Firebase Cloud Messaging (<strong>FCM</strong>) is a free (at least in this moment) cross-platform solution for messages and notifications for <strong>Android</strong>, <strong>iOS</strong> and <strong>Web applications</strong>.</p>
<p><img src="/img/2020-03-firebase-mp-rest-client.png" alt="firebase, push, microprofile, rest client" /></p>
<p>To enable push notification on client side you should create Firebase project and follow the <a href="https://firebase.google.com/docs/cloud-messaging">manual</a> or  <a href="https://github.com/firebase/quickstart-js/tree/master/messaging">examples</a>. From the server side perspective all you need to send push notification is:</p>
<ul>
<li><strong>Server key</strong> - will be created for your firebase project</li>
<li><strong>Instance ID token</strong> - id of specific subscribed instance (instance destination id)</li>
</ul>
<p>Firebase provides <strong><code>https://fcm.googleapis.com/fcm/send</code></strong> endpoint and very simple <a href="https://firebase.google.com/docs/cloud-messaging/http-server-ref">HTTP API</a> like</p>
<pre><code class="language-java">{
    &quot;to&quot;: &quot;&lt;Instance ID token&gt;&quot;,
    &quot;notification&quot;: {
      &quot;title&quot;: &quot;THIS IS MP REST CLIENT!&quot;,
      &quot;body&quot;: &quot;The quick brown fox jumps over the lazy dog.&quot;
      }
}
</code></pre>
<p>So, let's design simple Microprofile REST client to deal with above:</p>
<pre><code class="language-java">@Path(&quot;/&quot;)
@RegisterRestClient(configKey = &quot;push-api&quot;)
public interface PushClientService {

    @POST
    @Path(&quot;/fcm/send&quot;)
    @Produces(&quot;application/json&quot;)
    @ClientHeaderParam(name = &quot;Authorization&quot;, value = &quot;{generateAuthHeader}&quot;)
    void send(PushMessage msg);

    default String generateAuthHeader() {
        return &quot;key=&quot; + ConfigProvider.getConfig().getValue(&quot;firebase.server_key&quot;, String.class);
    }
}
</code></pre>
<pre><code class="language-java">public class PushMessage {

    public String to;
    public PushNotification notification;

    public static class PushNotification {
        public String title;
        public String body;
    }
}
</code></pre>
<p>and application.properties</p>
<pre><code class="language-bash"># firebase server key
firebase.server_key=&lt;SERVER_KEY&gt;
# rest client
push-api/mp-rest/url=https://fcm.googleapis.com/
</code></pre>
<p>Actually, this is it! Now you able to <code>@Inject</code>  PushClientService and enjoy push notifications as well.</p>
<pre><code class="language-java">@Inject
@RestClient
PushClientService pushService;
...
pushService.send(message);
</code></pre>
<p>If you would like to test how it works from client side perspective, - feel free to use <strong><a href="https://kostenko.org/blog/2020/03/firebase-push-microprofile-rest-client/index.htm">Test web application</a></strong> to generate instance ID token and check notifications delivery.</p>
<p>Described sample application source code with swagger-ui endpoint and firebase.server_key available on <a href="https://github.com/kostenkoserg/microprofile-quarkus-example">GitHub</a></p>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/03/firebase-push-microprofile-rest-client.html#disqus_thread" data-disqus-identifier="blog/2020/03/firebase-push-microprofile-rest-client.html">Comments</a></p>
				<hr/>
				<a href="https://kostenko.org/blog/2020/02/jwt-openapi-microprofile-quarkus.html"><h1>Well secured and documented REST API with Eclipse Microprofile and Quarkus</h1></a>
				<p>20 February 2020</p>
  			<p><p>Eclipse Microprofile specification provides several many helpful sections about building well designed microservice-oriented applications. <strong>OpenAPI</strong>, <strong>JWT Propagation</strong> and <strong>JAX-RS</strong> - the ones of them.<br />
<img src="/img/2020-02-jwt-openapi-jaxrs-microprofile.png" alt="microprofile, jwt, openapi, jax-rs" /><br />
To see how it works on practice let's design two typical REST resources: insecured <strong>token</strong> to generate JWT and secured  <strong>user</strong>, based on Quarkus Microprofile implementation.</p>
<p>Easiest way to bootstrap Quarkus application from scratch is generation project structure by provided starter page - <strong><a href="https://code.quarkus.io/">code.quarkus.io</a></strong>. Just select build tool you like and extensions you need. In our case it is:</p>
<ul>
<li><strong>SmallRye JWT</strong></li>
<li><strong>SmallRye OpenAPI</strong></li>
</ul>
<p>I prefer <strong>gradle</strong>, - and my <code>build.gradle</code> looks pretty simple</p>
<pre><code class="language-java">group 'org.kostenko'
version '1.0.0'
plugins {
    id 'java'
    id 'io.quarkus'
}
repositories {
     mavenLocal()
     mavenCentral()
}
dependencies {
    implementation 'io.quarkus:quarkus-smallrye-jwt'
    implementation 'io.quarkus:quarkus-smallrye-openapi'
    implementation 'io.quarkus:quarkus-resteasy-jackson'    
    implementation 'io.quarkus:quarkus-resteasy'
    implementation enforcedPlatform(&quot;${quarkusPlatformGroupId}:${quarkusPlatformArtifactId}:${quarkusPlatformVersion}&quot;)
    testImplementation 'io.quarkus:quarkus-junit5'
    testImplementation 'io.rest-assured:rest-assured'
}
compileJava {
    options.compilerArgs &lt;&lt; '-parameters'
}
</code></pre>
<p>Now we are ready to improve standard <strong>JAX-RS</strong> service with <strong>OpenAPI</strong> and <strong>JWT</strong> stuff:</p>
<pre><code class="language-java">@RequestScoped
@Path(&quot;/user&quot;)
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
@Tags(value = @Tag(name = &quot;user&quot;, description = &quot;All the user methods&quot;))
@SecurityScheme(securitySchemeName = &quot;jwt&quot;, type = SecuritySchemeType.HTTP, scheme = &quot;bearer&quot;, bearerFormat = &quot;jwt&quot;)
public class UserResource {

    @Inject
    @Claim(&quot;user_name&quot;)
    Optional&lt;JsonString&gt; userName;

    @POST
    @PermitAll
    @Path(&quot;/token/{userName}&quot;)
    @APIResponses(value = {
        @APIResponse(responseCode = &quot;400&quot;, description = &quot;JWT generation error&quot;),
        @APIResponse(responseCode = &quot;200&quot;, description = &quot;JWT successfuly created.&quot;, content = @Content(schema = @Schema(implementation = User.class)))})
    @Operation(summary = &quot;Create JWT token by provided user name&quot;)
    public User getToken(@PathParam(&quot;userName&quot;) String userName) {
        User user = new User();
        user.setJwt(TokenUtils.generateJWT(userName));
        return user;    
    }

    @GET
    @RolesAllowed(&quot;user&quot;)
    @Path(&quot;/current&quot;)
    @SecurityRequirement(name = &quot;jwt&quot;, scopes = {})
    @APIResponses(value = {
        @APIResponse(responseCode = &quot;401&quot;, description = &quot;Unauthorized Error&quot;),
        @APIResponse(responseCode = &quot;200&quot;, description = &quot;Return user data&quot;, content = @Content(schema = @Schema(implementation = User.class)))})
    @Operation(summary = &quot;Return user data by provided JWT token&quot;)
    public User getUser() {
        User user = new User();
        user.setName(userName.get().toString());
        return user;
    }
}
</code></pre>
<p>First let's take a brief review of used <strong><a href="https://github.com/eclipse/microprofile-open-api">Open API</a></strong> annotations:</p>
<ul>
<li><code>@Tags(value = @Tag(name = &quot;user&quot;, description = &quot;All the user methods&quot;))</code> -  Represents a tag. Tag is a meta-information you can use to help organize your API end-points.</li>
<li><code>@SecurityScheme(securitySchemeName = &quot;jwt&quot;, type = SecuritySchemeType.HTTP, scheme = &quot;bearer&quot;, bearerFormat = &quot;jwt&quot;)</code> - Defines a security scheme that can be used by the operations.</li>
<li><code>@APIResponse(responseCode = &quot;401&quot;, description = &quot;Unauthorized Error&quot;)</code> - Corresponds to the OpenAPI response model object which  describes a single response from an API Operation.</li>
<li><code>@Operation(summary = &quot;Return user data by provided JWT token&quot;)</code> - Describes an operation or typically a HTTP method against a specific path.</li>
<li><code>@Schema(implementation = User.class)</code> - Allows the definition of input and output data types.</li>
</ul>
<p>To more details about Open API annotations, please refer to the <strong><a href="https://github.com/eclipse/microprofile-open-api/blob/master/spec/src/main/asciidoc/microprofile-openapi-spec.adoc">MicroProfile OpenAPI Specification</a></strong>.</p>
<p>After start the application, you will able to get your Open API description in the  <strong>.yaml</strong> format by the next URL <a href="http://0.0.0.0:8080/openapi">http://0.0.0.0:8080/openapi</a> or even enjoy <strong>Swagger UI</strong> as well by <a href="http://0.0.0.0:8080/swagger-ui/">http://0.0.0.0:8080/swagger-ui/</a> :<br />
<img src="/img/2020-02-swagger-ui.png" alt="microprofile, openapi, swagger-ui" /></p>
<p><strong>Note</strong> By default swagger-ui available in the dev mode only. If you would like to keep swagger on production, - add next property to your <code>application.properties</code></p>
<pre><code class="language-java">quarkus.swagger-ui.always-include=true
</code></pre>
<p>Second part of this post is a <strong><a href="https://github.com/eclipse/microprofile-jwt-auth">JWT role based access control(RBAC)</a></strong> for microservice endpoints. JSON Web Tokens are an open, industry standard  <a href="https://tools.ietf.org/html/rfc7519">RFC 7519</a> method for representing claims securely between two parties and below we will see how easy it can be integrated in your application with Eclipse Microprofile.</p>
<p>As JWT suggests usage of cryptography - we need to generate public\private key pair before start coding:</p>
<pre><code class="language-bash"># Generate a private key
openssl genpkey -algorithm RSA -out private_key.pem -pkeyopt rsa_keygen_bits:2048

# Derive the public key from the private key
openssl rsa -pubout -in private_key.pem -out public_key.pem
</code></pre>
<p>Now we are able to generate JWT and sign data with our private key in the, for example, next way:</p>
<pre><code class="language-java">public static String generateJWT(String userName) throws Exception {

    Map&lt;String, Object&gt; claimMap = new HashMap&lt;&gt;();
    claimMap.put(&quot;iss&quot;, &quot;https://kostenko.org&quot;);
    claimMap.put(&quot;sub&quot;, &quot;jwt-rbac&quot;);
    claimMap.put(&quot;exp&quot;, currentTimeInSecs + 300)
    claimMap.put(&quot;iat&quot;, currentTimeInSecs);
    claimMap.put(&quot;auth_time&quot;, currentTimeInSecs);
    claimMap.put(&quot;jti&quot;, UUID.randomUUID().toString());
    claimMap.put(&quot;upn&quot;, &quot;UPN&quot;);
    claimMap.put(&quot;groups&quot;, Arrays.asList(&quot;user&quot;));
    claimMap.put(&quot;raw_token&quot;, UUID.randomUUID().toString());
    claimMap.put(&quot;user_bane&quot;, userName);

    return Jwt.claims(claimMap).jws().signatureKeyId(&quot;META-INF/private_key.pem&quot;).sign(readPrivateKey(&quot;META-INF/private_key.pem&quot;));
}
</code></pre>
<p>For additional information about JWT structure, please refer <strong><a href="https://jwt.io/introduction/">https://jwt.io</a></strong></p>
<p>Time to review our application security stuff:<br />
<code>@RequestScoped</code> -  It is not about security as well. But as JWT is request scoped we need this one to work correctly;<br />
<code>@PermitAll</code> - Specifies that all security roles are allowed to invoke the specified method;<br />
<code>@RolesAllowed(&quot;user&quot;)</code> - Specifies the list of roles permitted to access method;<br />
<code>@Claim(&quot;user_name&quot;)</code> - Allows us inject provided by JWT field;</p>
<p>To configure JWT in your <code>application.properties</code>, please add</p>
<pre><code class="language-bash">quarkus.smallrye-jwt.enabled=true
mp.jwt.verify.publickey.location=META-INF/public_key.pem
mp.jwt.verify.issuer=https://kostenko.org

# quarkus.log.console.enable=true
# quarkus.log.category.&quot;io.quarkus.smallrye.jwt&quot;.level=TRACE
# quarkus.log.category.&quot;io.undertow.request.security&quot;.level=TRACE
</code></pre>
<p>And actually that is it, - if you try to reach <code>/user/current</code> service without or with bad JWT token in the <code>Authorization</code> header - you will get  <strong>HTTP 401 Unauthorized</strong> error.</p>
<p>curl example:</p>
<pre><code class="language-java">curl -X GET &quot;http://localhost:8080/user/current&quot; -H &quot;accept: application/json&quot; -H &quot;Authorization: Bearer eyJraWQiOiJNRVRBLUlORi9wcml2YXRlX2tleS5wZW0iLCJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWIiOiJqd3QtcmJhYyIsInVwbiI6IlVQTiIsInJhd190b2tlbiI6IjQwOWY3MzVkLTQyMmItNDI2NC1iN2UyLTc1YTk0OGFjMTg3MyIsInVzZXJfbmFtZSI6InNlcmdpaSIsImF1dGhfdGltZSI6MTU4MjE5NzM5OSwiaXNzIjoiaHR0cHM6Ly9rb3N0ZW5rby5vcmciLCJncm91cHMiOlsidXNlciJdLCJleHAiOjkyMjMzNzIwMzY4NTQ3NzU4MDcsImlhdCI6MTU4MjE5NzM5OSwianRpIjoiMzNlMGMwZjItMmU0Yi00YTczLWJkNDItNDAzNWQ4NTYzODdlIn0.QteseKKwnYJWyj8ccbI1FuHBgWOk98PJuN0LU1vnYO69SYiuPF0d9VFbBada46N_kXIgzw7btIc4zvHKXVXL5Uh3IO2v1lnw0I_2Seov1hXnzvB89SAcFr61XCtE-w4hYWAOaWlkdTAmpMSUt9wHtjc0MwvI_qSBD3ol_VEoPv5l3_W2NJ2YBnqkY8w68c8txL1TnoJOMtJWB-Rpzy0XrtiO7HltFAz-Gm3spMlB3FEjnmj8-LvMmoZ3CKIybKO0U-bajWLPZ6JMJYtp3HdlpsiXNmv5QdIq1yY7uOPIKDNnPohWCgOhFVW-bVv9m-LErc_s45bIB9djwe13jFTbNg&quot;
</code></pre>
<p>Source code of described sample application available on <a href="https://github.com/kostenkoserg/microprofile-quarkus-example">GitHub</a></p>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/02/jwt-openapi-microprofile-quarkus.html#disqus_thread" data-disqus-identifier="blog/2020/02/jwt-openapi-microprofile-quarkus.html">Comments</a></p>
				<hr/>
				<a href="https://kostenko.org/blog/2020/02/jpa-relation-mappings.html"><h1>Simple note about using JPA relation  mappings</h1></a>
				<p>14 February 2020</p>
  			<p><p>There is a lot of typical examples how to build JPA <code>@OneToMany</code> and <code>@ManyToOne</code> relationships in your Jakarta EE application. And usually it looks like:</p>
<pre><code class="language-java">@Entity
@Table(name = &quot;author&quot;)
public class Author {
    @OneToMany
    private List&lt;Book&gt; book;
    ...
}
</code></pre>
<pre><code class="language-java">@Entity
@Table(name = &quot;book&quot;)
public class Book {
    @ManyToOne
    private Author author;
    ...
}
</code></pre>
<p>This code looks pretty clear, but on my opinion <strong>you should NOT USE this style</strong> in your real world application. From years of JPA using experience i definitely can say that sooner or later your project will stuck with known performance issues and holy war questions about: <strong>N+1</strong>, <strong>LazyInitializationException</strong>, <strong>Unidirectional @OneToMany</strong> , <strong>CascadeTypes</strong> ,<strong>LAZY vs EAGER</strong>, <strong>JOIN FETCH</strong>, <strong>Entity Graph</strong>, <strong>Fetching lot of unneeded data</strong>, <strong>Extra queries (for example: select Author by id before persist Book)</strong> etcetera.  Even if you are have answers for each potential issue above, usually proposed solution will add unreasonable complexity to the project.</p>
<p>To avoid potential issues i recommend to follow next rules:</p>
<ul>
<li>Avoid using of <code>@OneToMany</code> at all</li>
<li>Use <code>@ManyToOne</code> to build constrains but work with  <strong>ID</strong> instead of Entity</li>
</ul>
<p>Unfortunately, simple snippet below does not work as expected in case <code>persist</code></p>
<pre><code class="language-java">@ManyToOne(targetEntity = Author.class)
private long authorId;
</code></pre>
<p>But,we can use next one instead of</p>
<pre><code class="language-java">@JoinColumn(name = &quot;authorId&quot;, insertable = false, updatable = false)
@ManyToOne(targetEntity = Author.class)
private Author author;

private long authorId;

public long getAuthorId() {
    return authorId;
}

public void setAuthorId(long authorId) {
    this.authorId = authorId;
}
</code></pre>
<p>Hope, this two simple rules helps you enjoy all power of JPA with KISS and decreasing count of complexity.</p>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/02/jpa-relation-mappings.html#disqus_thread" data-disqus-identifier="blog/2020/02/jpa-relation-mappings.html">Comments</a></p>
				<hr/>
				<a href="https://kostenko.org/blog/2020/01/infinispan-distributed-cache-issues.html"><h1>ISPN000299: Unable to acquire lock after 15 seconds for key</h1></a>
				<p>05 February 2020</p>
  			<p><p>Distributed cache is a wide used technology that provides useful possibilities to share state whenever it necessary. Wildfly supports distributed cache through <a href="https://infinispan.org/">infinispan</a> subsystem and actually it works well, but in case height load and concurrent data access you may run into a some issues like:</p>
<ul>
<li>ISPN000299: Unable to acquire lock after 15 seconds for key</li>
<li>ISPN000924: beforeCompletion() failed for SynchronizationAdapter</li>
<li>ISPN000160: Could not complete injected transaction.</li>
<li>ISPN000136: Error executing command PrepareCommand on Cache</li>
<li>ISPN000476: Timed out waiting for responses for request</li>
<li>ISPN000482: Cannot create remote transaction GlobalTx</li>
</ul>
<p>and others.</p>
<p>In my case i had two node cluster with next infinispan configuration:</p>
<pre><code class="language-java">/profile=full-ha/subsystem=infinispan/cache-container=myCache/distributed-cache=userdata:add()
/profile=full-ha/subsystem=infinispan/cache-container=myCache/distributed-cache=userdata/component=transaction:add(mode=BATCH)
</code></pre>
<p><strong>distributed</strong> cache above means that number of copies are maintained, however this is typically less than the number of nodes in the cluster. From other point of view, to provide redundancy and fault tolerance you should configure enough amount of <strong>owners</strong> and obviously <strong>2</strong> is the necessary minimum here. So, in case usage small cluster and keep in mind the <a href="https://issues.redhat.com/browse/JDG-1318">BUG</a>, - i recommend use <strong>replicated-cache</strong> (all nodes in a cluster hold all keys)</p>
<p>Please, compare <a href="https://infinispan.org/docs/dev/titles/clustering/clustering.html#which_cache_mode_should_i_use">Which cache mode should I use?</a> with your needs.</p>
<p>Solution:</p>
<pre><code class="language-java">/profile=full-ha/subsystem=infinispan/cache-container=myCache/distributed-cache=userdata:remove()
/profile=full-ha/subsystem=infinispan/cache-container=myCache/replicated-cache=userdata:add()
/profile=full-ha/subsystem=infinispan/cache-container=myCache/replicated-cache=userdata/component=transaction:add(mode=NON_DURABLE_XA, locking=OPTIMISTIC)
</code></pre>
<p>Note!, <code>NON_DURABLE_XA</code> doesn't keep any transaction recovery information and if you still getting <code>Unable to acquire lock</code> errors on application critical data - you can try to resolve it by some <strong>retry</strong> policy and <strong>fail-fast</strong> transaction:</p>
<pre><code class="language-java">/profile=full-ha/subsystem=infinispan/cache-container=myCache/distributed-cache=userdata/component=locking:write-attribute(name=acquire-timeout, value=0)
</code></pre>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/01/infinispan-distributed-cache-issues.html#disqus_thread" data-disqus-identifier="blog/2020/01/infinispan-distributed-cache-issues.html">Comments</a></p>
				<hr/>
				<a href="https://kostenko.org/blog/2020/01/sql-spying-with-wildfly.html"><h1>Logging for JPA SQL queries with Wildfly</h1></a>
				<p>10 January 2020</p>
  			<p><p>Logging for real SQL queries is very important in case using any ORM solution, - as you never can be sure <strong>which</strong> and <strong>how many</strong> requests will send JPA provider to do <code>find</code>, <code>merge</code>, <code>query</code> or some other operation.</p>
<p>Wildfly uses Hibernate as JPA provider and provides few standard ways to enable SQL logging:</p>
<p><strong>1.</strong> Add <code>hibernate.show_sql</code> property to your <strong>persistence.xml</strong> :</p>
<pre><code class="language-java">&lt;properties&gt;
    ...
    &lt;property name=&quot;hibernate.show_sql&quot; value=&quot;true&quot; /&gt;
    ...
&lt;/properties&gt;
</code></pre>
<pre><code class="language-java">INFO  [stdout] (default task-1) Hibernate: insert into blogentity (id, body, title) values (null, ?, ?)
INFO  [stdout] (default task-1) Hibernate: select blogentity0_.id as id1_0_, blogentity0_.body as body2_0_, blogentity0_.title as title3_0_ from blogentity blogentity0_ where blogentity0_.title=?
</code></pre>
<p><strong>2.</strong> Enable <code>ALL</code> log level for <code>org.hibernate</code> category like:</p>
<pre><code class="language-java">/subsystem=logging/periodic-rotating-file-handler=sql_handler:add(level=ALL, file={&quot;path&quot;=&gt;&quot;sql.log&quot;}, append=true, autoflush=true, suffix=.yyyy-MM-dd,formatter=&quot;%d{yyyy-MM-dd HH:mm:ss,SSS} %-5p [%c] (%t) %s%e%n&quot;)
/subsystem=logging/logger=org.hibernate.SQL:add(use-parent-handlers=false,handlers=[&quot;sql_handler&quot;])
/subsystem=logging/logger=org.hibernate.type.descriptor.sql.BasicBinder:add(use-parent-handlers=false,handlers=[&quot;sql_handler&quot;])
</code></pre>
<pre><code class="language-java">DEBUG [o.h.SQL] insert into blogentity (id, body, title) values (null, ?, ?)
TRACE [o.h.t.d.s.BasicBinder] binding parameter [1] as [VARCHAR] - [this is body]
TRACE [o.h.t.d.s.BasicBinder] binding parameter [2] as [VARCHAR] - [title]
DEBUG [o.h.SQL] select blogentity0_.id as id1_0_, blogentity0_.body as body2_0_, blogentity0_.title as title3_0_ from blogentity blogentity0_ where blogentity0_.title=?
TRACE [o.h.t.d.s.BasicBinder] binding parameter [1] as [VARCHAR] - [title]
</code></pre>
<p><strong>3.</strong> Enable spying of SQL statements:</p>
<pre><code class="language-java">/subsystem=datasources/data-source=ExampleDS/:write-attribute(name=spy,value=true)
/subsystem=logging/logger=jboss.jdbc.spy/:add(level=DEBUG)
</code></pre>
<pre><code class="language-java">DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [DataSource] getConnection()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [Connection] prepareStatement(insert into blogentity (id, body, title) values (null, ?, ?), 1)
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [PreparedStatement] setString(1, this is body)
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [PreparedStatement] setString(2, title)
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [PreparedStatement] executeUpdate()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [PreparedStatement] getGeneratedKeys()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] next()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] getMetaData()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] getLong(1)
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] close()
...
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [DataSource] getConnection()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [Connection] prepareStatement(select blogentity0_.id as id1_0_, blogentity0_.body as body2_0_, blogentity0_.title as title3_0_ from blogentity blogentity0_ where blogentity0_.title=?)
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [PreparedStatement] setString(1, title)
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [PreparedStatement] executeQuery()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] next()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] getLong(id1_0_)
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] wasNull()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] getString(body2_0_)
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] wasNull()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] getString(title3_0_)
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] wasNull()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] next()
DEBUG [j.j.spy] java:jboss/datasources/ExampleDS [ResultSet] close()
</code></pre>
<p>So, from above we can see that variants <strong>2</strong> and <strong>3</strong> is most useful as allows to log queries with parameters. From other point of view - SQL logging can generate lot of unneeded debug information on production. To avoid garbage data in your log files, feel free to use <strong><a href="https://access.redhat.com/documentation/en-us/red_hat_jboss_enterprise_application_platform/6.4/html/administration_and_configuration_guide/chap-the_logging_subsystem#Filter_Expressions_for_Logging">Filter Expressions for Logging</a></strong></p>
</p>
				<p class="text-right"><a href="https://kostenko.org/blog/2020/01/sql-spying-with-wildfly.html#disqus_thread" data-disqus-identifier="blog/2020/01/sql-spying-with-wildfly.html">Comments</a></p>
				<hr/>

		<ul class="pager">
				<li class="previous"><a href="https://kostenko.org/2">Previous</a></li>
			<li">Page: 3/10 (<a href="../archive.html">archive</a>)</li>
				<li class="next"><a href="https://kostenko.org/4">Next</a></li>
		</ul>
		</div>
		<div id="push"></div>
    </div>

    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2019 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.6.4</a></p>
      </div>
    </div>

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../js/jquery-1.11.1.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
    <!--script src="../js/prettify.js"></script-->
		<script src="../js/prism.js"></script>

		<script id="dsq-count-scr" src="//kostenko-org.disqus.com/count.js" async></script>
  </body>
</html>
