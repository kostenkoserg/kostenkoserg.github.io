<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>https://kostenko.org</link>
    <atom:link href="https://kostenko.org/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Чт, 1 окт 2020 14:00:00 +0300</pubDate>
    <lastBuildDate>Чт, 1 окт 2020 14:00:00 +0300</lastBuildDate>

    <item>
      <title>Проблемы с подключением JMX Wildfly (очень медленно и прекращается)</title>
      <link>https://kostenko.org/blog/2019/08/wildfly-jconsole-mbeans-list-problem.html</link>
      <pubDate>Пн, 19 авг 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/08/wildfly-jconsole-mbeans-list-problem.html</guid>
      	<description>
	&lt;p&gt;JMX (Java Management Extensions ) - это технология, которая предоставляет нам возможность мониторинга приложеий (серверов приложения) с помощью &lt;strong&gt;MBeans (Managed Bean)&lt;/strong&gt; объектов.&lt;br /&gt;
Список поддерживаемых MBeans можно получить с помощью инструмента &lt;strong&gt;JConsole&lt;/strong&gt;, который уже включен в JDK. Поскольку JMX не обеспечивает строго определенный протокол коммуникации - реализация может отличаться в зависимости от производителя.&lt;br /&gt;
Например, для подключения к серверу приложений Wildfly вам необходимо использовать включенный в дистрибутиву скрипт &lt;code&gt;jconsole.sh&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;&amp;lt;WFLY_HOME&amp;gt;/bin/jconsole.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;или добавить &lt;code&gt;&amp;lt;WFLY_HOME&amp;gt;/bin/client/jboss-client.jar&lt;/code&gt; в classpath:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;jconsole J-Djava.class.path=$JAVA_HOME\lib\tools.jar;$JAVA_HOME\lib\jconsole.jar;jboss-client.jar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;По умолчанию Wildfly использует &lt;code&gt;timeout = 60s&lt;/code&gt; для &lt;strong&gt;удаленных JMX-соединений&lt;/strong&gt;, после того как это соединение будет разорвано:&lt;br /&gt;
&lt;img src=&quot;/img/2019-08-jmx-jconsole.png&quot; alt=&quot;jconsole terminated connection&quot; /&gt;&lt;br /&gt;
Чтобы изменить значение timeout, используйте свойство &lt;code&gt;org.jboss.remoting-jmx.timeout&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;./jconsole.sh -J-Dorg.jboss.remoting-jmx.timeout=300
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но увеличение таймаутов не всегда является хорошим решением.&lt;br /&gt;
Итак, давайте искать причину медленной работы. Чтобы создать список MBeans, jconsole  рекурсивно запрашивает ВСЕ MBean, что может быть очень медленным в случае большого количества развертываний и большого количества логгеров. (Reported issue: &lt;a href=&quot;https://issues.jboss.org/browse/WFCORE-3186&quot;&gt;WFCORE-3186&lt;/a&gt;). Частичное решение заключается в уменьшении количества логов файлов путем измениния rotating типа из &lt;code&gt;periodic-size-rotating-file-handler&lt;/code&gt; на &lt;code&gt;size-rotating-file-handler&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Другой причиной крайне медленной работы может быть&lt;code&gt;Batch subsystem (JBeret)&lt;/code&gt;. Он хранит много рабочей информации в своих таблицах (в памяти или на удаленной БД, зависит от конфигурации). Если эти таблицы достаточно большие - это может негативно сказаться на производительность сервера.&lt;br /&gt;
Так что, если вам не нужны эти данные, просто периодически очищайте их (например, каждое повторное развертывание, если вы делаете это достаточно часто):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;TRUNCATE TABLE PARTITION_EXECUTION CASCADE;
TRUNCATE TABLE STEP_EXECUTION CASCADE;
TRUNCATE TABLE JOB_EXECUTION CASCADE;
TRUNCATE TABLE JOB_INSTANCE CASCADE;  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;С другой точки зрения, получений ВСЕХ MBeans не самое хорошое решение. Поэтому, просто используйте инструменты, которые позволят вам найти MBeans по пути.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Jakarta EE мультимодульный шаблон приложения</title>
      <link>https://kostenko.org/blog/2019/08/ee-application-multi-module-template.html</link>
      <pubDate>Чт, 8 авг 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/08/ee-application-multi-module-template.html</guid>
      	<description>
	&lt;p&gt;В этом посту я поделюсь простым и полезным &lt;strong&gt;gradle&lt;/strong&gt; шаблоном для создания мультимодульного Jakarta EE приложения. Мы реализуем один из типичных, который состоит из REST контроллера (&lt;strong&gt;module1&lt;/strong&gt;) и некоторой основной логики (&lt;strong&gt;module2&lt;/strong&gt;). Общая картина архитектуры нашего приложения выглядит вот так:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019-08-ee-multimodule-template-arch.png&quot; alt=&quot;EE multi module application&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Итак, давайте сделаем инициализацию проекта с помощью следующего gradle шаблона:&lt;br /&gt;
&lt;code&gt;settings.gradle:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;rootProject.name = &apos;ee-application-multi-module-gradle-template&apos;
include &apos;module1&apos;
include &apos;module2:module2-api&apos;, &apos;module2:module2-core&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;root build.gradle:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;defaultTasks &apos;clean&apos;, &apos;build&apos;
subprojects {
    ext.libraryVersions = [
        javaee                  : &apos;8.0&apos;,
    ]
    defaultTasks &apos;clean&apos;, &apos;build&apos;
    repositories {
        jcenter()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Выше, мы описали начальную структуру приложения, где &lt;strong&gt;module1&lt;/strong&gt; является плоским подпроектом для нашего контроллера, а &lt;strong&gt;module2&lt;/strong&gt; является нашей основной логикой, которая состоит из подпроектов &lt;code&gt;API&lt;/code&gt; и &lt;code&gt;Core&lt;/code&gt;. В качестве контроллера, мы будем использовать  основную логику API, и мы решили разделить приложение на модули (что означает отсутсвие общеорганизационных архивов) - наши подпроекты должны быть достаточно простыми:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;module1 build.gradle:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;apply plugin: &apos;war&apos;
dependencies {
    compile project(&apos;:module2:module2-api&apos;)
    providedCompile &amp;quot;javax:javaee-api:${libraryVersions.javaee}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;module2:module2-api:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;apply plugin: &apos;java&apos;
dependencies {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;module2:module2-core:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;apply plugin: &apos;war&apos;
dependencies {
    compile project(&apos;:module2:module2-api&apos;)
    providedCompile &amp;quot;javax:javaee-api:${libraryVersions.javaee}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;На самом деле, это всё!&lt;br /&gt;
Теперь мы можем реализовать наш контроллер следующим образом:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Path(&amp;quot;/&amp;quot;)
@Stateless
@Consumes(MediaType.APPLICATION_JSON)
@Produces(MediaType.APPLICATION_JSON)
public class TestEndpoint {

    @EJB(lookup = TestService.TEST_SERVICE_JNDI)
    TestService testService;

    @GET
    @Path(&amp;quot;/test&amp;quot;)
    public Response test() {
        SomethingDto something = testService.doSomething();
        return Response.ok().entity(something.getMessage()).build();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В свою очередь, основная логика &lt;code&gt;API&lt;/code&gt; содержиться в &lt;code&gt;Interface&lt;/code&gt; и &lt;code&gt;DTO&lt;/code&gt;:&lt;br /&gt;
&lt;code&gt;TestService.java:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public interface TestService {

  String TEST_SERVICE_NAME = &amp;quot;test-service&amp;quot;;
  String TEST_SERVICE_JNDI =&amp;quot;java:global/module2-core/&amp;quot; + TEST_SERVICE_NAME;

  SomethingDto doSomething();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SomethingDto.java:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class SomethingDto implements Serializable{
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В конце концов, основная логика &lt;code&gt;Core&lt;/code&gt; состоит из логики, реализующей API:&lt;br /&gt;
&lt;code&gt;TestServiceImpl.java&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Remote(TestService.class)
@Stateless(name = TestService.TEST_SERVICE_NAME)
public class TestServiceImpl implements TestService {

    @PersistenceContext
    EntityManager entityManager;

    @Override
    public SomethingDto doSomething() {
        TestEntity entity = entityManager.find(TestEntity.class, Long.MAX_VALUE);
        return new SomethingDto(&amp;quot;Hello Jakarta EE world!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Описанная архитектура приложений Jakarta EE позволяет нам наслаждаться всеми возможностями ЕЕ с абсолютно прозрачными взаимодействиями между модулями и в то же время оставаться близким к дизайну микросервисов - поскольку у нас нет ограничений в использований одного контейнера для всех модулей.&lt;/p&gt;
&lt;p&gt;Исходный код, доступен на &lt;a href=&quot;https://github.com/kostenkoserg/ee-application-multi-module-gradle-template&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Как споймать &apos;убитые&apos; сигналы в Java</title>
      <link>https://kostenko.org/blog/2019/08/java-catch-os-signals.html</link>
      <pubDate>Ср, 7 авг 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/08/java-catch-os-signals.html</guid>
      	<description>
	&lt;p&gt;Вы можете отправлять разные сигналы в ваше приложение, используя команду &lt;strong&gt;kill -l&lt;/strong&gt;. По умолчанию &lt;strong&gt;kill&lt;/strong&gt; будет отправлять сигнао &lt;code&gt;TERM&lt;/code&gt;. Java по умолчанию ловит несколько типов сигналов, например&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;kill -3 &amp;lt;PID&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;будет дампать трассировку стека Java к стандартным ошибкам&lt;/p&gt;
&lt;p&gt;Кроме того, вы можете поймать &lt;code&gt;сигнал&lt;/code&gt; внутри вашего приложения, как&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class App {
    public static void main(String... s) throws Exception {

        Signal.handle(new Signal(&amp;quot;HUP&amp;quot;), signal -&amp;gt; {
            System.out.println(signal.getName() + &amp;quot; (&amp;quot; + signal.getNumber() + &amp;quot;)&amp;quot;);
        });

        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        Thread.sleep(1000l);
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
        }).start();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Список доступных сигналов, которые вы можете получить, выполнив команду &lt;code&gt;kill -l&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;kostenko@kostenko:~$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Обратите внимание! Не все сигналы могут быть перехвачены в приложении, некоторые из них зарезервированы в ОС. Например, если вы попытается обратать  &lt;strong&gt;kill -SIGKILL (kill -9)&lt;/strong&gt;, то вы получите:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Exception in thread &amp;quot;main&amp;quot; java.lang.IllegalArgumentException: Signal already used by VM or OS: SIGKILL
	at java.base/jdk.internal.misc.Signal.handle(Signal.java:173)
	at jdk.unsupported/sun.misc.Signal.handle(Signal.java:157)
&lt;/code&gt;&lt;/pre&gt;

	</description>
    </item>
    <item>
      <title>Wildfly. Настройка показателей балансировки нагрузки</title>
      <link>https://kostenko.org/blog/2019/08/wildfly-load-balancing-metrics.html</link>
      <pubDate>Вт, 6 авг 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/08/wildfly-load-balancing-metrics.html</guid>
      	<description>
	&lt;p&gt;Ранее я писал о &lt;a href=&quot;https://kostenko.org/blog/2019/04/wildfly-cluster-domain-mode.html&quot;&gt;Кластер доменного режима Wildfly и балансировка нагрузки из коробки&lt;/a&gt;. Но что, если мы хотим выполнить балансировку зависящей от конкретного поведения сервера?&lt;/p&gt;
&lt;p&gt;Подсистема Wildfly &lt;code&gt;mod_cluster&lt;/code&gt; предоставляет нам несколько предопределенных типов показателей для определения наилучшей балансировки запросов:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;cpu&lt;/strong&gt;: на основе загрузки процессора&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mem&lt;/strong&gt;: основано на использовании системной памяти&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;heap&lt;/strong&gt;: на основе использования кучи&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sessions&lt;/strong&gt;: на основе количества веб-сессий&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;requests&lt;/strong&gt;: на основе количества запросов / сек&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;send-traffic&lt;/strong&gt;: based on outgoing requests traffic&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;receive-traffic&lt;/strong&gt;: на основе трафика исходящих POST запросов&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;busyness&lt;/strong&gt;: вычисляет на основе количества потоков из использования пула потоков, которые заняты обслуживанием запросов&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;connection-pool&lt;/strong&gt;: на основе соединений JCA&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Также вы можете настроить &lt;strong&gt;weight&lt;/strong&gt; (влияние метрики на другие метрики) и свойства &lt;strong&gt;capacity&lt;/strong&gt; ;&lt;br /&gt;
Ниже приведен пример того, как изменить значение по умолчанию на основе балансировки ЦП на балансировку на основе busyness + ЦП:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/subsystem=modcluster/mod-cluster-config=configuration/dynamic-load-provider=configuration/load-metric=cpu:remove()
/subsystem=modcluster/mod-cluster-config=configuration:add-metric(type=busyness,weight=2)
/subsystem=modcluster/mod-cluster-config=configuration:add-metric(type=cpu,weight=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если этих предопределенных типов недостаточно, вы можете обеспечить &lt;code&gt;custom-load-metric&lt;/code&gt;, реализовав &lt;code&gt;org.jboss.modcluster.load.metric.impl.AbstractLoadMetric&lt;/code&gt;. Для возможности использования вашей пользовательской метрики,- вам необходимо скопировать упакованный JAR-файл в модуль &lt;code&gt;modcluster&lt;/code&gt; и обновить&lt;code&gt;module.xml&lt;/code&gt;. Теперь вы можете использовать свою собственную метрику с вашей конфигурацией, как:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt; &amp;lt;custom-load-metric class=&amp;quot;org.kostenko.examples.wldfly.modcluster.MyBalancingMetric&amp;quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

	</description>
    </item>
    <item>
      <title>Встроенный сервер Jetty урезает ответы</title>
      <link>https://kostenko.org/blog/2019/08/embedded-jetty-server-cut-responses.html</link>
      <pubDate>Вт, 6 авг 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/08/embedded-jetty-server-cut-responses.html</guid>
      	<description>
	&lt;p&gt;Jetty сервер имеет множество вариантов конфигурации. Один из них, это &lt;code&gt;OutputBufferSize&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;HttpConfiguration httpConfig = new HttpConfiguration();
httpConfig.setOutputBufferSize(1024);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если это свойство будет назначено значение меньше, чем ваш ответ - jetty просто будет обрезать обрезать последний.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>WFLYEJB0054: Failed to marshal EJB parameters</title>
      <link>https://kostenko.org/blog/2019/08/WFLYEJB0054.html</link>
      <pubDate>Пн, 5 авг 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/08/WFLYEJB0054.html</guid>
      	<description>
	&lt;p&gt;Обычно ошибка &lt;code&gt;WFLYEJB0054: Failed to marshal EJB parameters&lt;/code&gt; может быть вызвана по следующим причинам:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ваш объект передачи данных не имплементируется  Serializable&lt;/li&gt;
&lt;li&gt;Ваш объект передачи данных не существует в пути к классу модуля назначения (например, если вы используете  DTO  без строгой типизации)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Кроме того, вы можете словить эту ошибку с абсолютно неожиданным сценарием и нечеткой трассировкой стека, когда ваш EJB выбрасывает несколько непроверяемых ошибок со стековой трассировкой, которая имеет объекты из точек выше.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>SQL хак. Вставить, если не сущетсвует</title>
      <link>https://kostenko.org/blog/2019/07/sql-trick-insert-if-noe-exists.html</link>
      <pubDate>Ср, 24 июл 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/07/sql-trick-insert-if-noe-exists.html</guid>
      	<description>
	&lt;p&gt;Следующий SQL хак позволит вам выполнить условный &lt;code&gt;INSERT&lt;/code&gt; для вашего запроса.&lt;/p&gt;
&lt;p&gt;Например, давайте сделаем вставку, если записи ещё не будет существовать:&lt;/p&gt;
&lt;p&gt;SQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO my_table (id, name)  
    SELECT 1, &apos;name&apos; FROM dual  WHERE NOT EXISTS (SELECT 1 FROM my_table WHERE ID = 1);
&lt;/code&gt;&lt;/pre&gt;

	</description>
    </item>
    <item>
      <title>JMS обнаружение дублирующихся сообщений с Wildfly</title>
      <link>https://kostenko.org/blog/2019/07/wildfly-jms-duplicate-detection.html</link>
      <pubDate>Пт, 19 июл 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/07/wildfly-jms-duplicate-detection.html</guid>
      	<description>
	&lt;p&gt;Для поддержки JMS спецификация Wildfly использует Apache ActiveMQ Artemis в подсистеме active-mq. Последнее предоставляет механизм фильтрации повторяющихся сообщений без изменения кода приложения.&lt;/p&gt;
&lt;p&gt;Чтобы включить обнаружение повторяющихся сообщений, вам просто нужно установить специальное свойтсво сообщения с уникальным значением.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;message.setStringProperty(&amp;quot;_AMQ_DUPL_ID&amp;quot;, uniqueId);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Итак, давайте посмотрим, как это работает на практике и создадим простой Message Driven Bean для использования сообщений:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@JMSDestinationDefinition(
        name = DuplicateJMSTestBean.DUPLICATE_QUEUE,
        interfaceName = &amp;quot;javax.jms.Queue&amp;quot;
)
@MessageDriven(activationConfig = {
    @ActivationConfigProperty(propertyName = &amp;quot;destinationLookup&amp;quot;, propertyValue = DuplicateJMSTestBean.DUPLICATE_QUEUE),
    @ActivationConfigProperty(propertyName = &amp;quot;destinationType&amp;quot;, propertyValue = &amp;quot;javax.jms.Queue&amp;quot;)
})
@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
public class DuplicateJMSTestBean implements MessageListener {

    public final static String DUPLICATE_QUEUE = &amp;quot;java:global/jms/duplicateTestQueue&amp;quot;;

    @Override
    public void onMessage(Message msg) {
        System.out.println(&amp;quot;Got new message.&amp;quot;);
        MessageStorage.messages.add(msg);
        try {
            Thread.sleep(5_000l);
        } catch(Exception ignore) {}
        System.out.println(&amp;quot;Message  successfully processed&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И простую конечную точку JAX-RS для создания сообщений&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Path(&amp;quot;/&amp;quot;)
@Stateless
@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
public class DuplicateTestEndpoint {

    @Inject
    private JMSContext context;
    @Resource(lookup = DuplicateJMSTestBean.DUPLICATE_QUEUE)
    private Queue queue;

    @GET
    @Path(&amp;quot;/sendmessage&amp;quot;)
    public Response sendMessage(@QueryParam(&amp;quot;duplicate-id&amp;quot;) String duplicateId) {
        try {
            ObjectMessage message = context.createObjectMessage();
            if (duplicateId == null) {
                context.createProducer().send(queue, message);
            } else {
                message.setStringProperty(&amp;quot;_AMQ_DUPL_ID&amp;quot;, duplicateId);
                context.createProducer().send(queue, message);
            }
            return Response.ok().entity(&amp;quot;Message was sent.  Recieved &amp;quot; + MessageStorage.messages.size() + &amp;quot; messagges: &amp;quot; + MessageStorage.messages).build();
        } catch (Throwable e) {
            return Response.ok().entity(&amp;quot;Error: &amp;quot; + e).build();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь в случае, если мы отправим сообщение с тем же &lt;code&gt;_AMQ_DUPL_ID&lt;/code&gt; без транзакции по адресу &lt;code&gt;http://127.0.0.1:8080/jms-examples/sendmessage?duplicate-id=myuniqueid&lt;/code&gt;, мы получим в логах:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;WARN [org.apache.activemq.artemis.core.server] (Thread-448 (ActiveMQ-server-org.apache.activemq.artemis.core.server.impl.ActiveMQServerImpl$5@e47887a)) AMQ222059: Duplicate message detected - message will not be routed. Message information:
CoreMessage[messageID=1505,durable=true,userID=3d27afde-a9fa-11e9-af5d-0242e352ec80,priority=4, timestamp=Fri Jul 19 10:53:04 EEST 2019,expiration=0, durable=true, address=jms.queue.jms-examples_jms-examples_jms-examples_java:global/jms/duplicateTestQueue,size=416,properties=TypedProperties[__AMQ_CID=38587489-a9fa-11e9-af5d-0242e352ec80,_AMQ_DUPL_ID=myuniqueid,_AMQ_ROUTING_TYPE=1]]@145077408
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и сообщение НЕ будет потребляться потребителем. Если вы отправите сообщение в транзакции - вы получите &lt;code&gt;Исключение&lt;/code&gt; при коммите.&lt;/p&gt;
&lt;p&gt;Имейте в виду, что для хранения идентификаторов activemq, используют круговой кэш фиксированого размера.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/subsystem=messaging-activemq/server=default:read-attribute(name=id-cache-size)
{
    &amp;quot;outcome&amp;quot; =&amp;gt; &amp;quot;success&amp;quot;,
    &amp;quot;result&amp;quot; =&amp;gt; 20000
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Поэтому, это значение должно быть достаточно большими для того, чтобы избежать перезаписи. Также, вы можете сконфигурировать постоянный кэш или этого не делать (по умолчанию: &lt;code&gt;true&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/subsystem=messaging-activemq/server=default:write-attribute(name=persist-id-cache,value=false)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Исходный код, доступен на  &lt;a href=&quot;https://github.com/kostenkoserg/ee-jms-examples&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Jenkins. Приятно иметь плагины</title>
      <link>https://kostenko.org/blog/2019/07/jenkins-nice-to-have-plugins.html</link>
      <pubDate>Пт, 5 июл 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/07/jenkins-nice-to-have-plugins.html</guid>
      	<description>
	&lt;p&gt;Jenkins - главный инструмент автоматизации с открытым исходным кодом, который предоставляет множество плагинов для улучшения вашего CI.&lt;br /&gt;
Ниже приведены некоторые из них, которые, на мой взгляд, станут полезным для любого проекта.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. &lt;a href=&quot;https://plugins.jenkins.io/build-monitor-plugin&quot;&gt;Build Monitor Plugin&lt;/a&gt;&lt;/strong&gt; - обеспечивает весьма ощутимое представление о статусе выбранных заданий Jenkins;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019-07-jenkins-build-monitor-plugin.png&quot; alt=&quot;Build Monitor Plugin&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2. &lt;a href=&quot;https://plugins.jenkins.io/git-parameter&quot;&gt;Git Parameter Plugin&lt;/a&gt;&lt;/strong&gt; - добавляет возможность выбирать ветки, теги или ревизии из git-репозитория, настроенного в проекте;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019-07-jenkins-git-parameter-plugin.png&quot; alt=&quot;Git Parameter Plugin&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;3. &lt;a href=&quot;https://plugins.jenkins.io/htmlpublisher&quot;&gt;HTML Publisher Plugin&lt;/a&gt;&lt;/strong&gt; - публикует HTML-отчёты, которые ваш билд сгенерировал для работы и сборки страниц;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019-07-jenkins-html-report-plugin.png&quot; alt=&quot;Git Parameter Plugin&quot; /&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Взаимная блокировка подсистемы Wildfly ActiveMQ</title>
      <link>https://kostenko.org/blog/2019/06/wildfly-activemq-deadlock.html</link>
      <pubDate>Сб, 29 июн 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/06/wildfly-activemq-deadlock.html</guid>
      	<description>
	&lt;p&gt;В последнее время у меня была необычно высокая загрузка ЦП на случайном экземпляре Wildfly cluster.&lt;br /&gt;
Дамп потока показывает причину проблемы:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Found one Java-level deadlock:
=============================

&amp;quot;Thread-1 (ActiveMQ-server-org.apache.activemq.artemis.core.server.impl.ActiveMQServerImpl$2@46fcd20a-1114701218)&amp;quot;:
  waiting to lock Monitor@0x00007f45f02e20f8 (Object@0x0000000603407950, a org/apache/activemq/artemis/core/server/cluster/impl/ClusterConnectionImpl$MessageFlowRecordImpl),
  which is held by &amp;quot;Thread-29 (ActiveMQ-client-global-threads-2129186403)&amp;quot;
&amp;quot;Thread-29 (ActiveMQ-client-global-threads-2129186403)&amp;quot;:
  waiting to lock Monitor@0x00007f46203b5518 (Object@0x00000004cc79a7b8, a org/apache/activemq/artemis/core/server/impl/QueueImpl),
  which is held by &amp;quot;Thread-1 (ActiveMQ-server-org.apache.activemq.artemis.core.server.impl.ActiveMQServerImpl$2@46fcd20a-1114701218)&amp;quot;

Found a total of 1 deadlock.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ниже приведена часть официальной документации:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Если для thread-pool-max-size установлено положительное целое число больше, чем 0, пул потоков будет ограничен. Если поступают запросы и в пуле нету свободных потоков, запросы будут блокироваться до тех пор, пока поток не станет доступным. Рекомендуется использовать пул ограниченных потоков с осторожностью, поскольку это может привести к &lt;strong&gt;тупиковым ситуациям&lt;/strong&gt;, если верхняя граница настроена слишком низко.&amp;quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;По-этому решение будет таковым:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/subsystem=messaging-activemq/server=default:write-attribute(name=thread-pool-max-size,value=-1)
&lt;/code&gt;&lt;/pre&gt;

	</description>
    </item>
    <item>
      <title>Как использовать пользовательский ClassLoader для загрузки JAR-файлов во время выполнения</title>
      <link>https://kostenko.org/blog/2019/06/runtime-class-loading.html</link>
      <pubDate>Пт, 28 июн 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/06/runtime-class-loading.html</guid>
      	<description>
	&lt;p&gt;Для загрузки классов во время выполнения java используют механизм ClassLoader, который основан на нескольких основных принципах:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;делегирование&lt;/strong&gt; - по умолчанию используют &lt;code&gt;parent-first delegation&lt;/code&gt;, - наследник ClassLoader будет использоваться, если родитель не может найти или загрузить класс. Это поведение можно изменить на &lt;code&gt;child-first&lt;/code&gt;, переписав &lt;code&gt;ClassLoader.loadClass(...)&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;видимость&lt;/strong&gt; - наследник ClassLoader может видеть все классы, загруженные родителем, но наоборот не может;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;уникальность&lt;/strong&gt; - позволяет загрузить класс только один раз, что в основном достигается делегированием и гарантирует, что наследник ClassLoader не перезагрузит класс, уже загруженного родителя;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Основные сценарии использования пользовательского ClassLoader:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Инструментарий класса&lt;/strong&gt; - изменение классов во время выполнения. Например, для модульного тестирование, отладки или мониторинга;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Изоляция выполнения&lt;/strong&gt; - изолировать несколько сред выполнения в одном процессе, делая видимыми только подмножество классов для конкретного потока, как это делается в средах EE;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Итак, давайте посмотрим, как выглядит использование пользовательского ClassLoader с точки зрения исходного кода:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;File&amp;gt; jars = Arrays.asList(new File(&amp;quot;/tmp/jars&amp;quot;).listFiles());
URL[] urls = new URL[files.size()];
for (int i = 0; i &amp;lt; jars.size(); i++) {
    try {
        urls[i] = jars.get(i).toURI().toURL();
    } catch (Exception e) {
        e.printStackTrace();
    }
}
URLClassLoader childClassLoader = new URLClassLoader(urls, ClassLoader.getSystemClassLoader());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Затем загрузите класс с пользовательским ClassLoader:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Class.forName(&amp;quot;org.kostenko.examples.core.classloader.ClassLoaderTest&amp;quot;, true , childClassLoader);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Обратите внимение! Если ваши загруженные библеотеки используют некоторые ресурсы, такие как свойства или что-то ещё, вам нужно продоставить загрузчик класса котекста:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;Thread.currentThread().setContextClassLoader(childClassLoader);  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Кроме того, вы можете использовать пользовательские ClassLoaders для загрузки служб с помощью Java Service Provider Interface(SPI)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;ServiceLoader&amp;lt;MyProvider&amp;gt; serviceLoader = ServiceLoader.load(MyProvider.class, childClassLoader);
...
&lt;/code&gt;&lt;/pre&gt;

	</description>
    </item>
    <item>
      <title>Разработка DSL API на Java</title>
      <link>https://kostenko.org/blog/2019/05/design-dsl-api-java.html</link>
      <pubDate>Пн, 27 мая 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/05/design-dsl-api-java.html</guid>
      	<description>
	&lt;p&gt;Хорошо разработанный API - очень важен, так как его будут использовать не только вы, но и кто-то другой, если вы ожидаете. По-этому, что бы построить читаемый и хорошо написанный DLS(domain specific language) на Java, обычно используют паттерн Builder с несколькими простыми правилами:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Думай дважды про названия для методов;&lt;/li&gt;
&lt;li&gt;Ограничивай доступность значений для каждого шага.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Окей, давайте посмотрим, как это выглядит с точки зрения исходного кода...&lt;/p&gt;
&lt;p&gt;Точка входа Design API&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class MyAPI {
    public static UserBuilder.Registration asUser() {
        return new UserBuilder.User();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Design builder, использующий интерфейсы для ограничения доступности значений, зависит от текущего шага.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class UserBuilder {
    public static class User implements Registration, Login, Password, Apply {
        private String login;
        private String password;

        @Override
        public Login doRegistration() {
            return this;
        }
        @Override
        public Password withLogin(String login) {
            this.login = login;
            return this;
        }
        @Override
        public Apply withPassword(String password) {
            this.password = password;
            return this;
        }
        @Override
        public void apply() {
            // ...
        }
    }

    public interface Registration {
        Login doRegistration();
    }
    public interface Login {
        Password withLogin(String login);
    }
    public interface Password {
        Apply withPassword(String password);
    }
    public interface Apply {
        void apply();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тогда использование, без попытки ошибиться, выглядит вот так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;asUser().doRegistration()
        .withLogin(&amp;quot;login&amp;quot;).withPassword(&amp;quot;password&amp;quot;)
        .apply();
&lt;/code&gt;&lt;/pre&gt;

	</description>
    </item>
    <item>
      <title>Моё видео про кластеризацию доменного режима Wildfly</title>
      <link>https://kostenko.org/blog/2019/05/wildfly-domain-mode-cluster-video.html</link>
      <pubDate>Чт, 2 мая 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/05/wildfly-domain-mode-cluster-video.html</guid>
      	<description>
	
Загрузил новое видео на YouTube про кластеризацию доменного режима Wildfly. 

&lt;br/&gt;&lt;br/&gt;
&lt;div class=&quot;row&quot;&gt;
    &lt;iframe align =&quot;center&quot; class=&quot;col-md-offset-3 col-lg-6 col-md-6 col-sm-12 col-xs-12&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/dIT9e945OHs&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

	</description>
    </item>
    <item>
      <title>Кластер доменного режима Wildfly и балансировка нагрузки из коробки</title>
      <link>https://kostenko.org/blog/2019/04/wildfly-cluster-domain-mode.html</link>
      <pubDate>Пн, 15 апр 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/04/wildfly-cluster-domain-mode.html</guid>
      	<description>
	&lt;p&gt;Wildfly Application Server предоставляет нам два возможных режима настройки кластерной среды для приложений Java EE.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Автономный режим (Standalone mode)&lt;/strong&gt; - каждый автономный экземпляр имеет свой собственный интерфейс управления и конфигурацию. Вы можете управлять одним экземпляром за раз. Конфигурация помещена в файл &lt;code&gt;standalone.xml&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Доменный режим (Domain mode)&lt;/strong&gt; - все экземпляры Wildfly управляются с помощью специального процесса оркестровки, называемого &lt;code&gt;контроллер домена&lt;/code&gt;. С помощью контроллера домена вы можете управлять группой серверов. Также вы можете управлять группами. Каждая группа серверов может иметь их собственные конфигурации, развертывания и т.д. Конфигурация находится в файлах &lt;code&gt;domain.xml&lt;/code&gt; и &lt;code&gt;host.xml&lt;/code&gt;.&lt;br /&gt;
Пример группы серверов Wildfly:&lt;br /&gt;
&lt;img src=&quot;/img/2019-04-wildfly-cluster-domain-mode.png&quot; alt=&quot;wildfly-cluster-domain-mode&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;С версии 10 Wildfly добавляет поддержку для использования подсистемы &lt;code&gt;Undertow&lt;/code&gt; в качестве баланса нагрузки. Итак, теперь все, что нам нужно для создания кластерной инфраструктуры Java EE, это только Wildfly. Давай сделаем это.&lt;/p&gt;
&lt;p&gt;Скачайте последнюю версию сервера приложений с &lt;a href=&quot;https://wildfly.org/downloads/&quot;&gt;https://wildfly.org/downloads/&lt;/a&gt; и после распакуйте дистрибутиву. Чтобы запустить Wildfly в доменном режим, пожалуйста выполните:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;kostenko@kostenko:/opt/wildfly-16.0.0.Final/bin$ ./domain.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Подключитесь к Wildfly CLI консоле&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;kostenko@kostenko:/opt/wildfly-16.0.0.Final/bin$ ./jboss-cli.sh -c
[domain@localhost:9990 /]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;По умолчанию в Wildfly предварительно настроены группы серверов &lt;code&gt;main-server-group&lt;/code&gt; и&lt;code&gt;other-server-group&lt;/code&gt;, поэтому нам нужно очистить существующие серверы:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;:stop-servers(blocking=true)
/host=master/server-config=server-one:remove
/host=master/server-config=server-two:remove
/host=master/server-config=server-three:remove
/server-group=main-server-group:remove
/server-group=other-server-group:remove
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Создайте новую группу серверов и серверов, используя профиль &lt;code&gt;full-ha&lt;/code&gt;, чтобы включить поддержку&lt;code&gt;mod_cluster&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/server-group=backend-servers:add(profile=full-ha, socket-binding-group=full-ha-sockets)
/host=master/server-config=backend1:add(group=backend-servers, socket-binding-port-offset=100)
/host=master/server-config=backend2:add(group=backend-servers, socket-binding-port-offset=200)

#start the backend servers
/server-group=backend-servers:start-servers(blocking=true)

#add system properties (so we can tell them apart)
/host=master/server-config=backend1/system-property=server.name:add(boot-time=false, value=backend1)
/host=master/server-config=backend2/system-property=server.name:add(boot-time=false, value=backend2)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Далее настройте группу серверов для балансировщика нагрузки.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;/server-group=load-balancer:add(profile=load-balancer, socket-binding-group=load-balancer-sockets)
/host=master/server-config=load-balancer:add(group=load-balancer)
/socket-binding-group=load-balancer-sockets/socket-binding=modcluster:write-attribute(name=interface, value=public)
/server-group=load-balancer:start-servers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь давайте разработаем простую конечную точку JAX-RS, чтобы показать, как она работает:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Path(&amp;quot;/clusterdemo&amp;quot;)
@Stateless
public class ClusterDemoEndpoint {

    @GET
    @Path(&amp;quot;/serverinfo&amp;quot;)
    public Response getServerInfo() {

        return Response.ok().entity(&amp;quot;Server: &amp;quot; + System.getProperty(&amp;quot;server.name&amp;quot;)).build();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Создайте проект и задеплойте его в группе &lt;code&gt;backend-servers&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;[domain@localhost:9990 /] deploy ee-jax-rs-examples.war --server-groups=backend-servers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И проверьте результат на &lt;code&gt;http://localhost:8080/ee-jax-rs-examples/clusterdemo/serverinfo&lt;/code&gt; :&lt;br /&gt;
&lt;img src=&quot;/img/2019-04-wildfly-cluster-domain-mode-1-2.gif&quot; alt=&quot;wildfly-cluster-domain-mode-1-2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Теперь мы можем легко добавить серверы в группу во время выполнения, и запросы будут автоматически балансироваться:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;[domain@localhost:9990 /] /host=master/server-config=backend3:add(group=backend-servers, socket-binding-port-offset=300)
[domain@localhost:9990 /] /host=master/server-config=backend3/system-property=server.name:add(boot-time=false, value=backend3)
[domain@localhost:9990 /] /server-group=backend-servers/:start-servers(blocking=true)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/img/2019-04-wildfly-cluster-domain-mode-1-2-3.gif&quot; alt=&quot;wildfly-cluster-domain-mode-1-2-3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Это всё!&lt;br /&gt;
Код этого блога доступен на GitHub:  &lt;a href=&quot;https://github.com/kostenkoserg/ee-jax-rs-examples/blob/master/src/main/java/org/kostenko/example/jaxrs/ClusterDemoEndpoint.java&quot;&gt;Demo application&lt;/a&gt;,  &lt;a href=&quot;https://github.com/kostenkoserg/wildfly-configuration-examples/blob/master/wildfly-domain-mode-cluster.cli&quot;&gt;Wildlfly CLI &lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Java EE CDI события. Динамический квалификатор.</title>
      <link>https://kostenko.org/blog/2019/04/java-ee-cdi-events.html</link>
      <pubDate>Пн, 8 апр 2019 00:00:00 +0300</pubDate>
      <guid isPermaLink="false">blog/2019/04/java-ee-cdi-events.html</guid>
      	<description>
	&lt;p&gt;Java ЕЕ предоставляет нам  хороший механизм для обработки событий, который является частью CDI для спецификации Java EE. Динамический CDI спецификатор может быть полезен для обработки событий, например, в domain driven архитектуре или при маршрутизации сообщений веб-сокета и т.д.&lt;/p&gt;
&lt;p&gt;Генерация простого события:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Named
public class MyEventSource {

    @Inject
    private Event&amp;lt;String&amp;gt; myEvent;

    public void fireEvent(){
        myEvent.fire(&amp;quot;Hello World!&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Наблюдатель события:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Named
public class MyEventObserver {
    public void observeEvent(@Observes String message){
        System.out.println(message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Используя CDI спецификатор,  можно определить, какой наблюдатель должен обработать событие&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Qualifier
@Retention(RUNTIME)
@Target({METHOD, FIELD, PARAMETER, TYPE})
public @interface Important {
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Например:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Named
public class MyEventSource {

    @Inject
    @Important
    private Event&amp;lt;String&amp;gt; myEvent;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Named
public class MyEventObserver {
  public void observeEvent(@Observes @Important String message){
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;По-умолчанию, событие будет обработано обсервером в текущей транзакции, но можно изменить это поведение,  используя &lt;code&gt;@Observes&lt;/code&gt; атрибут  &lt;code&gt;during&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Named
public class TransactionEventObserver {
    public void observeImportantMessage(@Observes(during = TransactionPhase.AFTER_SUCCESS) String message){
        System.out.println(message);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Доступны следующие значения:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IN_PROGRESS&lt;/li&gt;
&lt;li&gt;BEFORE_COMPLETION&lt;/li&gt;
&lt;li&gt;AFTER_COMPLETION&lt;/li&gt;
&lt;li&gt;AFTER_FAILURE&lt;/li&gt;
&lt;li&gt;AFTER_SUCCESS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Теперь давайте посмотрим как можно квалифицировать CDI события динамически. В примере ниже мы создадим обсервер для обработки пользовательских событий (вход в систему, выход, регистрация и т.д.), полученных из некого абстрактного источника.&lt;/p&gt;
&lt;p&gt;Итак, сначала нам нужно создать &lt;code&gt;Qualifier&lt;/code&gt; с доступными значениями событий&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Qualifier
@Target({METHOD, FIELD, PARAMETER, TYPE})
@Retention(RUNTIME)
public @interface UserEvent {

    Routes value();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;где Routes - это enum с доступными значениями, например:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public enum Routes {
  LOGIN,
  LOGOUT,
  REGISTRATION
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Потом нам нужно создать дочерний от &lt;code&gt;javax.enterprise.util.AnnotationLiteral&lt;/code&gt; класс  для возможности использования квалификатора динамически.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class UserEventBinding extends AnnotationLiteral&amp;lt;UserEvent&amp;gt; implements UserEvent {

    Routes routes;

    public UserEventBinding(Routes routes) {
        this.routes = routes;
    }

    @Override
    public Routes value() {
        return routes;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь давайте сгенерируем событие, используя динамический выбор наблюдателей&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Named
public class UserEventSource {

    @Inject
    private Event&amp;lt;String&amp;gt; userEvent;

    public void fireEvent(Routes route){
        userEvent.select(new UserEventBinding(route)).fire(&amp;quot;Instead of string you can use your object&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Время показать, как выглядит наш Observer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import static Routes.*;
...

@Named
public class UserObserver {

    public void registration(@Observes @UserEvent(REGISTRATION) String eventData) {
      ....
    }

    public void login(@Observes @UserEvent(LOGIN) String eventData) {
      ....
    }

    public void logout(@Observes @UserEvent(LOGOUT) String eventData) {
      ....
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;P.S. В Java EE 8 с CDI 2.0 вы можете использовать асинхронные события CDI с помощью метода &lt;code&gt;fireAsync&lt;/code&gt; и аннотации &lt;code&gt;@ObserveAsync&lt;/code&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Wildfly обработка больших запросов</title>
      <link>https://kostenko.org/blog/2019/03/wildfly-large-request.html</link>
      <pubDate>Вт, 26 мар 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/03/wildfly-large-request.html</guid>
      	<description>
	&lt;p&gt;По умолчанию подсистема Undertow в Wildfly AS настроена на обработку запросов с &lt;code&gt;max-post-size&lt;/code&gt;= 10MB. В случае, если ваш запрос, больше, чем 10 МБ, вы получите&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;java.io.IOException: UT000020: Connection terminated as request was larger than 10485760
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для увеличения этого параметра, можно отредактировать непосредственно &lt;code&gt;standalone&lt;/code&gt; или &lt;code&gt;domain&lt;/code&gt; конфигурации&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;subsystem xmlns=&amp;quot;urn:jboss:domain:undertow:3.1&amp;quot;&amp;gt;
  &amp;lt;buffer-cache name=&amp;quot;default&amp;quot;/&amp;gt;
  &amp;lt;server name=&amp;quot;default-server&amp;quot;&amp;gt;
    &amp;lt;http-listener name=&amp;quot;default&amp;quot; socket-binding=&amp;quot;http&amp;quot; max-post-size=&amp;quot;15728640&amp;quot; redirect-socket=&amp;quot;https&amp;quot; enable-http2=&amp;quot;true&amp;quot;/&amp;gt;
    &amp;lt;https-listener name=&amp;quot;https&amp;quot; socket-binding=&amp;quot;https&amp;quot; max-post-size=&amp;quot;15728640&amp;quot; security-realm=&amp;quot;SSLRealm&amp;quot;/&amp;gt;
....
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;или используйте команды CLI как показано ниже:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/subsystem=undertow/server=default-server/http-listener=default/:write-attribute(name=max-post-size,value=15728640)
/subsystem=undertow/server=default-server/https-listener=https/:write-attribute(name=max-post-size,value=15728640)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Заметьте! Если Вы используете Wildfly в доменном режиме с балансировщиком нагрузки AJP, вам также может потребоваться изменить  &lt;code&gt;max-post-size&lt;/code&gt; для &lt;code&gt;ajp-listener&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/subsystem=undertow/server=default-server/ajp-listener=ajp/:write-attribute(name=max-post-size,value=15728640)
&lt;/code&gt;&lt;/pre&gt;

	</description>
    </item>
    <item>
      <title>Видео знакомство с Hibernate Search</title>
      <link>https://kostenko.org/blog/2019/03/hibernate-search-intro-video.html</link>
      <pubDate>Ср, 20 мар 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/03/hibernate-search-intro-video.html</guid>
      	<description>
	
Опубликовано мое второе видео на YouTube (о Hibernate Search и интеграции с Wildfly)!

&lt;br/&gt;&lt;br/&gt;
&lt;div class=&quot;row&quot;&gt;
    &lt;iframe align =&quot;center&quot; class=&quot;col-md-offset-3 col-lg-6 col-md-6 col-sm-12 col-xs-12&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/RuGyErfhmL0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

	</description>
    </item>
    <item>
      <title>SQL хак. Условный COUNT для выражения  SELECT</title>
      <link>https://kostenko.org/blog/2019/03/sql-trick-conditional-count.html</link>
      <pubDate>Сб, 16 мар 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/03/sql-trick-conditional-count.html</guid>
      	<description>
	&lt;p&gt;Для выполнения условной логики в SQL &lt;code&gt;SELECT&lt;/code&gt;, можно использовать выражение &lt;code&gt;CASE&lt;/code&gt;. Следующий SQL хак  позволит вам выполнить условный &lt;code&gt;count()&lt;/code&gt; для вашего запроса.&lt;/p&gt;
&lt;p&gt;Например, чтобы выбрать количество записей с &lt;code&gt;id &amp;gt; 5&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;SQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT SUM(CASE WHEN id &amp;gt; 5 THEN 1 ELSE 0 END) FROM Table
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JPQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;entityManager.createQuery(&amp;quot;SELECT SUM(CASE WHEN b.id &amp;gt; 5 THEN 1 ELSE 0 END) FROM BlogEntity b&amp;quot;).getSingleResult()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Criteria API:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery&amp;lt;Number&amp;gt; query = cb.createQuery(Number.class);
Root&amp;lt;BlogEntity&amp;gt; blogEntity = query.from(BlogEntity.class);

query.select(
        cb.sum(
                cb.&amp;lt;Number&amp;gt;selectCase()
                        .when(cb.gt(blogEntity.get(&amp;quot;id&amp;quot;), 5), 1)
                        .otherwise(0)
        )
);

Number result = em.createQuery(query).getSingleResult();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Исходный код, доступен на  &lt;a href=&quot;https://github.com/kostenkoserg/jpa-examples/blob/master/src/test/java/org/kostenko/example/jpa/JpaConditionalCountTest.java&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Как поднять ssh тоннель на Linux</title>
      <link>https://kostenko.org/blog/2019/03/linux-build-ssh-tunnel.html</link>
      <pubDate>Пт, 15 мар 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/03/linux-build-ssh-tunnel.html</guid>
      	<description>
	&lt;p&gt;SSH тоннель позволяет перенаправлять локальный трафик через SSH на удаленный хост. Может быть использован, например, для соедиения с удаленным приложением, которое было запущено на локальном порту удаленного хоста.&lt;/p&gt;
&lt;p&gt;Например, чтобы соединиться с mysql, который был запущен на локальном порту &lt;code&gt;3306&lt;/code&gt; хоста  remotehost.com, вы можете использовать:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ssh -L 3366:localhost:3306 [USERNAME]@remotehost.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;или с использованием  &lt;a href=&quot;https://kostenko.org/blog/2019/02/linux-generate-private-shh-key.html&quot;&gt;SSH keys&lt;/a&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ssh -i [KEY_FILENAME] -L 3366:localhost:3306 [USERNAME]@remotehost.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После этого, вы можете соединиться с базой, используя любимый тулинг на localhost:3366&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Hibernate Search вступление. Развертывание на WildFly.</title>
      <link>https://kostenko.org/blog/2019/02/wildfly-hibernate-search.html</link>
      <pubDate>Чт, 21 фев 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/02/wildfly-hibernate-search.html</guid>
      	<description>
	&lt;p&gt;Hibernate  Search - это мощное решение для реализации возможностей полнотекстового поиска (как google или  amazon) в вашем ЕЕ приложении. Под капотом, для построения индекса, будет использоваться Apache Lucene напрямую, или через Elasticsearch. Hibernate Search может быть легко интегрирован с JPA, Hibernate ORM, Infinispan или другими источниками. Если вы используете Wildfly - вам повезло, - Hibernate Search с ним уже интегрирован.&lt;/p&gt;
&lt;p&gt;Итак, посмотрим, как это работает на практике ...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Давайте начнем с gradle проекта, используя hibernate-search и EE зависимости&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;apply plugin: &apos;java&apos;
apply plugin: &apos;war&apos;

sourceCompatibility = &apos;1.8&apos;
defaultTasks &apos;clean&apos;, &apos;build&apos;
ext.libraryVersions = [
    javaee                  : &apos;8.0&apos;,
    wildfly                 : &apos;15.0.1.Final&apos;,
    hibernatesearch         : &apos;5.11.1.Final&apos;,
    hibernateentitymanager  : &apos;5.4.1.Final&apos;,
    h2                      : &apos;1.4.198&apos;,
    dom4j                   : &apos;2.1.1&apos;,
    junit                   : &apos;4.12&apos;
]
configurations {
    wildfly
}
repositories {
    mavenCentral()
}
dependencies {
    wildfly &amp;quot;org.wildfly:wildfly-dist:${libraryVersions.wildfly}@zip&amp;quot;
    providedCompile &amp;quot;javax:javaee-api:${libraryVersions.javaee}&amp;quot;
    providedCompile &amp;quot;org.hibernate:hibernate-search-orm:${libraryVersions.hibernatesearch}&amp;quot;
    testCompile &amp;quot;junit:junit:${libraryVersions.junit}&amp;quot;
    testCompile &amp;quot;com.h2database:h2:${libraryVersions.h2}&amp;quot;
    testCompile &amp;quot;org.hibernate:hibernate-entitymanager:${libraryVersions.hibernateentitymanager}&amp;quot;
    testCompile &amp;quot;org.hibernate:hibernate-search-orm:${libraryVersions.hibernatesearch}&amp;quot;
    testCompile &amp;quot;org.dom4j:dom4j:${libraryVersions.dom4j}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**2. Создадим стандартную сущность JPA c Hibernate Search аннотациями **&lt;br /&gt;
&lt;code&gt;src/main/java/org/.../BlogEntity.java:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package org.kostenko.example.wildfly.hibernatesearch;

import javax.persistence.*;
import org.hibernate.search.annotations.*;

@Entity
@Indexed
public class BlogEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column
    @Field(store = Store.YES)
    private String title;

    @Column
    @Field(store = Store.YES)
    private String body;

    // getters, setters
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Основные аннотации Hibernate Search:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th&gt;Аннотация    &lt;/th&gt;&lt;th&gt; Описание&lt;/th&gt;&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;@Indexed      &lt;/td&gt;&lt;td&gt; Помечает, какие объекты должны быть индексированы; Позволяет переопределению имя индекса. Только объекты @Indexed могут быть найдены..&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;@Field        &lt;/td&gt;&lt;td&gt; Помечает поле объекта, которое будет индексировано. Существует несколько вариантов работы с индексируемыми полями: &lt;code&gt;store&lt;/code&gt; -  перечислимый тип, указывающий, должно ли значение поля быть сохранено в индексе. По умолчанию - &lt;code&gt;Store.NO&lt;/code&gt; (Значение поля не будет сохранено в индексе.) Хранение значений может быть полезным для использования в механизме Projections,- что позволит восстанавливать значения полей непосредственно из индекса, минуя запросы к СУБД, &lt;code&gt;index&lt;/code&gt; -  перечисление, определяющее, следует ли индексировать поле или нет. По умолчанию - &lt;code&gt;Index.YES&lt;/code&gt; &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;@DocumentId   &lt;/td&gt;&lt;td&gt; Позволяет переопределить идентификатор документа в индексе. По-умолчанию используется поля помеченное JPA-аннотацией @Id. &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;@SortableField&lt;/td&gt;&lt;td&gt; Помечает что индексируемое поле может быть сортируемым.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;3. Добавьте свойства hibernate-search в persistence.xml&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;src/test/resources/META-INF/persistence.xml :&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;persistence version=&amp;quot;2.0&amp;quot; xmlns=&amp;quot;http://java.sun.com/xml/ns/persistence&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&amp;quot;&amp;gt;
    &amp;lt;persistence-unit name=&amp;quot;myDSTest&amp;quot; transaction-type=&amp;quot;RESOURCE_LOCAL&amp;quot;&amp;gt;
        &amp;lt;provider&amp;gt;org.hibernate.jpa.HibernatePersistenceProvider&amp;lt;/provider&amp;gt;
        &amp;lt;class&amp;gt;org.kostenko.example.wildfly.hibernatesearch.BlogEntity&amp;lt;/class&amp;gt;
        &amp;lt;exclude-unlisted-classes&amp;gt;false&amp;lt;/exclude-unlisted-classes&amp;gt;
        &amp;lt;properties&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.dialect&amp;quot; value=&amp;quot;org.hibernate.dialect.HSQLDialect&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.hbm2ddl.auto&amp;quot; value=&amp;quot;create-drop&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.connection.driver_class&amp;quot; value=&amp;quot;org.hsqldb.jdbcDriver&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.connection.username&amp;quot; value=&amp;quot;sa&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.connection.password&amp;quot; value=&amp;quot;&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.connection.url&amp;quot; value=&amp;quot;jdbc:hsqldb:mem:testdb&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.showSql&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
            &amp;lt;!-- Hibernate Search --&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.search.default.directory_provider&amp;quot; value=&amp;quot;filesystem&amp;quot; /&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.search.default.indexBase&amp;quot; value=&amp;quot;/tmp/index1&amp;quot; /&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.search.default.indexmanager&amp;quot; value=&amp;quot;near-real-time&amp;quot; /&amp;gt;
        &amp;lt;/properties&amp;gt;
    &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как мы могли убедиться, добавить Hibernate Search в свое приложение достаточно легко, - всего пара аннотаций. Теперь Hibernate Search автоматически будет создавать индекс каждый раз, когда объект, будет изменен (создан, удален) через Hibernate ORM. Индекс может быть сохранен в &lt;code&gt;ram&lt;/code&gt; или &lt;code&gt;filesystem&lt;/code&gt;. Другие поставщики, также доступны.&lt;/p&gt;
&lt;p&gt;Итак, пора сделать простой тест и посмотреть, как это работает с &lt;strong&gt;Lucene queries&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;src/test/java/org/.../JpaHibernateSearchTest :&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class JpaHibernateSearchTest {

    private static EntityManager entityManager;
    private static FullTextEntityManager fullTextEntityManager;
    private static QueryBuilder queryBuilder;

    @BeforeClass
    public static void init() {
        entityManager = Persistence.createEntityManagerFactory(&amp;quot;myDSTest&amp;quot;).createEntityManager();
        fullTextEntityManager = Search.getFullTextEntityManager(entityManager);
        queryBuilder = fullTextEntityManager.getSearchFactory().buildQueryBuilder().forEntity(BlogEntity.class).get();
        for (int i = 0; i &amp;lt; 1000; i++) {
            BlogEntity blogEntity = new BlogEntity();
            blogEntity.setTitle(&amp;quot;Title&amp;quot; + i);
            blogEntity.setBody(&amp;quot;BodyBody Body&amp;quot; + i + &amp;quot; look at my horse my horse is a amazing &amp;quot; + i);
            entityManager.getTransaction().begin();
            entityManager.persist(blogEntity);
            entityManager.getTransaction().commit();
        }
        Assert.assertEquals(1000, entityManager.createQuery(&amp;quot;SELECT COUNT(b) FROM BlogEntity b&amp;quot;, Number.class).getSingleResult().intValue());
    }
    /**
     * Keyword Queries - searching for a specific word.
     */
    @Test
    public void shouldSearchByKeywordQuery() throws Exception {
        Query query = queryBuilder.keyword().onFields(&amp;quot;title&amp;quot;, &amp;quot;body&amp;quot;).matching(&amp;quot;Body999&amp;quot;).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class); // wrap Lucene query in a javax.persistence.Query
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();// execute search
        Assert.assertFalse(result.isEmpty());
        Assert.assertEquals(&amp;quot;Title999&amp;quot;, result.get(0).getTitle());
    }
    /**
     * Fuzzy Queries - we can define a limit of “fuzziness”
     */
    @Test
    public void shouldSearchByFuzzyQuery() throws Exception {
        Query query = queryBuilder.keyword().fuzzy().withEditDistanceUpTo(2).withPrefixLength(0).onField(&amp;quot;title&amp;quot;).matching(&amp;quot;TAtle999&amp;quot;).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class);
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();
        Assert.assertFalse(result.isEmpty());
        Assert.assertEquals(&amp;quot;Title999&amp;quot;, result.get(0).getTitle());
    }
    /**
     * Wildcard Queries - queries for which a part of a word is unknown (&apos;?&apos; - single character, &apos;*&apos; - character sequence)
     */
    @Test
    public void shouldSearchByWildcardQuery() throws Exception {
        Query query = queryBuilder.keyword().wildcard().onField(&amp;quot;title&amp;quot;).matching(&amp;quot;?itle*&amp;quot;).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class);
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();
        Assert.assertFalse(result.isEmpty());
        Assert.assertEquals(1000, result.size());
    }
    /**
     * Phrase Queries - search for exact or for approximate sentences
     */
    @Test
    public void shouldSearchByPhraseQuery() throws Exception {
        Query query = queryBuilder.phrase().withSlop(10).onField(&amp;quot;body&amp;quot;).sentence(&amp;quot;look amazing horse 999&amp;quot;).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class);
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();
        Assert.assertFalse(result.isEmpty());
        Assert.assertEquals(&amp;quot;Title999&amp;quot;, result.get(0).getTitle());
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В тесте, мы использовали основные юзкейсы. Но даже этого достаточно, чтобы почувствовать насколько &lt;code&gt;Apache Lucene search engine&lt;/code&gt; неплох. И увидеть, как легко его можно интегрировать с вашим приложением. Обратитесь к &lt;a href=&quot;https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/&quot;&gt;официальной документации&lt;/a&gt; для детелей.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Использование Hibernate Search с Wildfly&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Как я уже писал - Hibernate Search интегрирован в  Wildfly начиная с версии 10. Это означает, что эта функциональность активируется автоматически в случае, если вы используете по крайней мере одну ентити с &lt;code&gt;org.hibernate.search.annotations.Indexed&lt;/code&gt;.&lt;br /&gt;
Итак, все что нам нужно, чтобы показать как это работает вместе, - это просто реализовать простой веб-сервис с похожей на юнит тест логикой и запустить его на сервере.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Path(&amp;quot;/&amp;quot;)
@Stateless
public class HibernateSearchDemoEndpoint {

    @PersistenceContext
    EntityManager entityManager;

    /**
     * Persist 1000 entities and rebuild index
     * @return
     */
    @GET
    @Path(&amp;quot;/init&amp;quot;)
    @Transactional
    public Response init() {
        int count = entityManager.createQuery(&amp;quot;SELECT COUNT(b) FROM BlogEntity b&amp;quot;, Number.class).getSingleResult().intValue();
        long time = System.currentTimeMillis();
        for (int i = count; i &amp;lt; count + 1000; i++) {
            BlogEntity blogEntity = new BlogEntity();
            blogEntity.setTitle(&amp;quot;Title&amp;quot; + i);
            blogEntity.setBody(&amp;quot;Body Body Body&amp;quot; + i + &amp;quot; look at my horse my horse is a amazing &amp;quot; + i);
            entityManager.persist(blogEntity);
        }
        time = System.currentTimeMillis() - time;
        return Response.ok().entity(String.format(&amp;quot;1000 records persisted. Current records %s Execution time = %s ms.&amp;quot;, count + 1000, time)).build();
    }

    /**
     * Search by index
     * @param q - query string
     * @return
     */
    @GET
    @Path(&amp;quot;/search&amp;quot;)
    public Response search(@QueryParam(&amp;quot;q&amp;quot;) String q) {
        FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(entityManager);
        QueryBuilder queryBuilder = fullTextEntityManager.getSearchFactory().buildQueryBuilder().forEntity(BlogEntity.class).get();
        long time = System.currentTimeMillis();
        Query query = queryBuilder.keyword().onFields(&amp;quot;title&amp;quot;, &amp;quot;body&amp;quot;).matching(q).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class);
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();
        time = System.currentTimeMillis() - time;
        String resultStr = result.stream().map(Object::toString).collect(Collectors.joining(&amp;quot;,&amp;quot;));
        return Response.ok().entity( String.format(&amp;quot;Found %s results. [%s] Execution time = %s ms.&amp;quot;,result.size(),resultStr,time)).build();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь, давайте добавим таск в наш &lt;code&gt;build.gradle&lt;/code&gt; для запуска  Wildfly прямо из проекта&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;task removeWildfly(type:Delete) {
    delete &amp;quot;build/wildfly-${libraryVersions.wildfly}&amp;quot;
}
task resolveWildfly(type:Copy, dependsOn:removeWildfly) {
    destinationDir = buildDir
    from {zipTree(configurations.wildfly.singleFile)}
}
task run() {
    dependsOn &apos;resolveWildfly&apos;
    doLast {
        copy {
            from projectDir.toString() + &amp;quot;/build/libs/wildfly-hibernate-search-example.war&amp;quot;
            into projectDir.toString() + &amp;quot;/build/wildfly-${libraryVersions.wildfly}/standalone/deployments&amp;quot;
        }
        exec {
            workingDir = file(projectDir)
            commandLine &amp;quot;./build/wildfly-${libraryVersions.wildfly}/bin/standalone.sh&amp;quot;, &amp;quot;--debug&amp;quot;, &amp;quot;5005&amp;quot;
            ext.output = {
                return standardOutput.toString()
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; разархивирует wildfly в каталог проекта, задеплоит приложение и запустит сервер. Итак:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gradle &amp;amp;&amp;amp; gradle run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;проверим вывод, чтобы убедиться, что Hiberate создал Index соглсно  пути в  &lt;code&gt;persistence.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;...
15:15:37,386 INFO  [org.hibernate.search.store.impl.DirectoryProviderHelper] (MSC service thread 1-3) HSEARCH000041: Index directory not found, creating: &apos;/tmp/index2/org.kostenko.example.wildfly.hibernatesearch.BlogEntity&apos;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И, наконец, смотрим на результат в браузере&lt;br /&gt;
&lt;img src=&quot;/img/2019-02-hibernate-search-1.png&quot; alt=&quot;create_index&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/img/2019-02-hibernate-search-2.png&quot; alt=&quot;serach_by_index&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Исходный код проекта, доступен на &lt;a href=&quot;https://github.com/kostenkoserg/wildfly-hibernate-search-example&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Как сгенерировать ssh ключи в Linux</title>
      <link>https://kostenko.org/blog/2019/02/linux-generate-private-shh-key.html</link>
      <pubDate>Ср, 20 фев 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/02/linux-generate-private-shh-key.html</guid>
      	<description>
	&lt;p&gt;Часто, по соображения безопасности или юзабилити, предпочтительнее использовать ssh ключи вместо паролей. Для этого нужно:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Логинимся на удаленный инстанс&lt;/li&gt;
&lt;li&gt;Генерируем ключи&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ssh-keygen -t rsa -f ~/.ssh/[KEY_FILENAME] -C [USERNAME]
cat [KEY_FILENAME].pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Скачиваем приватный ключ  ([KEY_FILENAME]) себе&lt;/li&gt;
&lt;li&gt;Заходим на хост с использованием ключа&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;chmod 400 [KEY_FILENAME]
ssh -i [KEY_FILENAME] [USERNAME]@yourhost.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для того, что бы запретить логиниться с паролем и под рутом, отредактируйте  &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;PasswordAuthentication no
PermitRootLogin no
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Затем перезагрузите ssh сервер&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;

	</description>
    </item>
    <item>
      <title>Моё первое видео</title>
      <link>https://kostenko.org/blog/2019/02/github-jbake-blog-video.html</link>
      <pubDate>Сб, 16 фев 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/02/github-jbake-blog-video.html</guid>
      	<description>
	
Моё первое видео (о том как я делал это блог) на youtube!

&lt;br/&gt;&lt;br/&gt;
&lt;div class=&quot;row&quot;&gt;
    &lt;iframe align =&quot;center&quot; class=&quot;col-md-offset-3 col-lg-6 col-md-6 col-sm-12 col-xs-12&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/_0C2xTa8jsY&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

	</description>
    </item>
    <item>
      <title>Jbake. Добавляем теги, поддержку нескольких языков и аналитику</title>
      <link>https://kostenko.org/blog/2019/01/jbake-blog-improve.html</link>
      <pubDate>Сб, 19 янв 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/01/jbake-blog-improve.html</guid>
      	<description>
	&lt;h4&gt;1. Теги&lt;/h4&gt;
&lt;p&gt;Jbake поддерживает работу с тегами из коробки и при использовании тегов в описании будет генерироваться отдельная страница под каждый тег. Достаточно отредактировать параметр &lt;code&gt;render.tags&lt;/code&gt; в конфигурационном файле &lt;code&gt;jbake.properties&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;render.tags=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь в зависимости от того, где мы хотим разместить список тегов, редактируем соответствующий темплейт. Для этого блога я использую freemarker и решил вывести теги в меню в виде выпадающего списка. Соответственно, изменив  ``menu.ftl`, как показано ниже:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot;&amp;gt;
      &amp;lt;#list tags as tag&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;${content.rootpath}${tag.uri}&amp;quot;&amp;gt;${tag.name}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;/#list&amp;gt;
  &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Готово!&lt;/p&gt;
&lt;h4&gt;2. Контент на нескольких языках&lt;/h4&gt;
&lt;p&gt;К сожалению, Jbake пока не поддерживает мультиязычные блоги на уровне метаданных и для обеспечения этой функциональности мне пришлость проделать несколько нехитрых упражнений. Сперва, я просто хотел сделать полную копию с другим языком контента, но в случае любых изменений для шаблонов, скриптов, изображений - правки пришлось бы делать дважды. Что не есть хорошо.&lt;/p&gt;
&lt;p&gt;Вместо этого я просто создал каталог &lt;code&gt;content_ru&lt;/code&gt; в корне проекта.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;├── assets  
├── content  
├── content_ru
├── templates
├── jbake.properties
├── README.md  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;К счастью, в &lt;code&gt;jbake.properies&lt;/code&gt; есть возможность установить каталог контента, который будет использован при генерации, что позволяет держать несколько директорий в проекте.  Теперь сгенерировать мультиязычный блог можно используя скрипт:&lt;/p&gt;
&lt;p&gt;bakeblog.sh:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash

# Helper script to bake the blog
# Author: kostenko

export PATH=&amp;quot;/opt/jbake-2.6.3-bin/bin&amp;quot;:$PATH
rm -R ./output
# Building en version
export JBAKE_OPTS=&amp;quot;-Duser.language=EN&amp;quot;
jbake -b
# Build ru version
export JBAKE_OPTS=&amp;quot;-Duser.language=RU&amp;quot;
mv jbake.properties jbake.properties.orig
cat jbake.properties.orig &amp;gt;&amp;gt; jbake.properties
echo &amp;quot;content.folder=content_ru&amp;quot; &amp;gt;&amp;gt; jbake.properties
jbake -b . output/ru
# cleanup
rm jbake.properties
mv jbake.properties.orig jbake.properties
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Добавим возможность переключения языков в меню:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- switch language --&amp;gt;
&amp;lt;ul class=&amp;quot;nav navbar-nav navbar-right&amp;quot;&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/&amp;quot;&amp;gt;en&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/ru&amp;quot;&amp;gt;ru&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;На этом все!&lt;/p&gt;
&lt;h4&gt;3. Аналитика&lt;/h4&gt;
&lt;p&gt;Для того что бы подключить &lt;a href=&quot;https://analytics.google.com&quot;&gt;Google analytics&lt;/a&gt; нужно выполнить несколько простых шагов&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Зарегестировать ресурс в GA&lt;/li&gt;
&lt;li&gt;Получить сгенерированный GA фрагмент кода&lt;/li&gt;
&lt;li&gt;Вставить этот код в &lt;code&gt;header.ftl&lt;/code&gt; первой строкой блока &lt;code&gt;&amp;lt;HEAD&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- Global site tag (gtag.js) - Google Analytics --&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;script async src=&amp;quot;https://www.googletagmanager.com/gtag/js?id=&amp;lt;YOUR_GA_ID&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag(&apos;js&apos;, new Date());
    gtag(&apos;config&apos;, &apos;&amp;lt;YOUR_GA_ID&amp;gt;&apos;);
  &amp;lt;/script&amp;gt;
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;P.S. При желании к блогу можно подключить возможность оставлять комментарии, используя например &lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt;.&lt;br /&gt;
P.P.S. Код этого блога доступен на &lt;a href=&quot;https://github.com/kostenkoserg/kostenko.blog.src&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Как поднять блог на github и jbake</title>
      <link>https://kostenko.org/blog/2019/01/github-jbake-blog.html</link>
      <pubDate>Пт, 18 янв 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/01/github-jbake-blog.html</guid>
      	<description>
	&lt;p&gt;Развернуть свой персональный блог, блог компании или лендинг проекта используя &lt;a href=&quot;https://pages.github.com/&quot;&gt;github&lt;/a&gt; - задача, как оказалось, несложная и не требующая особых навыков. Здесь я, максимально конструктивно, постараюсь изложить основные шаги, которые необходимо сделать для того, что бы обзавестись личным блогом на небезизвестном ресурсе.&lt;/p&gt;
&lt;h4&gt;Шаг 1. Хостим статику на github&lt;/h4&gt;
&lt;p&gt;Для этого нам потребуются аккаунт на &lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt; и базовые навыки работы с &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;. К слову сказать, все ниже изложенное можно проделать и для конкурирующего сервиса &lt;a href=&quot;https://gitlab.com/&quot;&gt;gitlab&lt;/a&gt;, - где кому больше нравится.&lt;/p&gt;
&lt;p&gt;Далее, нужно просто создать проект, назвав его:  &amp;lt;логин&amp;gt;.github.io, например kostenkoserg.github.io&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/ru/img/my_github_srcshot.png&quot; alt=&quot;github pages project screenshot&quot; /&gt;&lt;/p&gt;
&lt;p&gt;В принципе, на этом вся подготовительная рабобта для хостинга статики и завершена. Теперь клонируем проект себе (пока пустой), создаём index.html и пушим в репозиторий:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ git clone https://github.com/kostenkoserg/kostenkoserg.github.io.git
$ cd kostenkoserg.github.io
$ echo &amp;quot;Hello World!&amp;quot;
$ git commit -m &amp;quot;my first github page&amp;quot;
$ git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Все! Страничка доступна по &lt;a href=&quot;https://kostenkoserg.github.io&quot;&gt;https://kostenkoserg.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/ru/img/first_github_page.png&quot; alt=&quot;first_github_page&quot; /&gt;&lt;br /&gt;
По желанию, к сайту можно подвязать уже существующий домен, если по каким-либо соображениям .github.io не подходит. Для этого нужно&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Добавить &lt;code&gt;A&lt;/code&gt; записи в настройках DNS провайдера с GitHub ипишниками&lt;/li&gt;
&lt;li&gt;В настройках проекта на  GitHub указать DNS имя&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Шаг 2. Генерация статического сайта с помощью Jbake&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://jbake.org/&quot;&gt;Jbake&lt;/a&gt; - это проект, с открытым исходным кодом, для генерации статических сайтов. Для Jbake доступна интеграция с  Gradle и Maven, из коробки поддержка Bootstrap и прозрачная интеграция с другими CSS фреймворками, а так же поддержка Freemarker, Groovy, Thymeleaf и Jade в качестве шаблонов.&lt;/p&gt;
&lt;p&gt;Для начала работы с Jbake, качаем дистрибутив с &lt;a href=&quot;https://jbake.org/download.html&quot;&gt;сайта проекта&lt;/a&gt; и распаковываем архив куда-то себе. После чего генерируем структуру своего сайта:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ cd myblog
$ /opt/jbake/bin/jbake -i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В результате получаем следующую структуру каталогов и немного тестового контента:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;├── assets
│   ├── css
│   │   ├── asciidoctor.css
│   │   ├── base.css
│   │   ├── bootstrap.min.css
│   │   └── prettify.css
│   ├── favicon.ico
│   ├── fonts
│   │   ├── ...
│   └── js
│       ├── bootstrap.min.js
│       ├── html5shiv.min.js
│       ├── jquery-1.11.1.min.js
│       └── prettify.js
├── content
│   ├── about.html
│   └── blog
│       └── 2013
│           ├── first-post.html
│           ├── second-post.md
│           └── third-post.adoc
├── jbake.properties
└── templates
    ├── archive.ftl
    ├── feed.ftl
    ├── footer.ftl
    ├── header.ftl
    ├── index.ftl
    ├── menu.ftl
    ├── page.ftl
    ├── post.ftl
    ├── sitemap.ftl
    └── tags.ftl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь генерируем сам сайт:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/opt/jbake/bin/jbake -b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В результате чего получим каталог &lt;code&gt;output&lt;/code&gt; с нашим статическим сайтом.&lt;br /&gt;
Проверить, что получилось можно по &lt;a href=&quot;http://localhost:8820/&quot;&gt;http://localhost:8820/&lt;/a&gt;, запустив всторенный сервер&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/opt/jbake/bin/jbake -s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/ru/img/jbake_default_site.png&quot; alt=&quot;jbake_default_site&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Всё! наш статический сайт готов! Для полноценного ведения блога, теперь достаточно отредактировать содержимое каталога &lt;code&gt;content&lt;/code&gt;, перегенерировать сайт и запушить полученный &lt;code&gt;output&lt;/code&gt; в, созданный на первом шаге, github репозиторий.&lt;/p&gt;
&lt;p&gt;Jbake поддерживает несколько форматов контента: HTML, Markdown, AsciiDoc, - что позволяет вести свой сайт, используя любой текстовый редактор. Я использую &lt;a href=&quot;https://atom.io/&quot;&gt;Atom&lt;/a&gt; и &lt;a href=&quot;https://www.markdownguide.org/basic-syntax/&quot;&gt;Markdown&lt;/a&gt;.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Первая запись в блоге</title>
      <link>https://kostenko.org/blog/2019/01/start-blogging.html</link>
      <pubDate>Чт, 17 янв 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/01/start-blogging.html</guid>
      	<description>
	&lt;p&gt;Мысли о собственном блоге посещали меня уже давно и достаточно регулярно, но в силу различных причин реализация задуманного откладывалась. Среди причин было и желание реализовать собственный движок для блогов (зачем-то), и поиск подходящих стилей (ведь так важно), и знакомство со специализированными решениями: wordpress, wix, blogger и другими...&lt;/p&gt;
&lt;p&gt;В итоге, в качестве платформы был выбран &lt;a href=&quot;https://pages.github.com/&quot;&gt;pages.github.io&lt;/a&gt; с его генератором статического контента &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;. Последнее показалось мне самым сбалансированным решеним: понятно, бесплантно,  быстро, надежно. Да и найти лучшее место для технического блога сегодня, наверное, трудно. По мере знакомства с  предметной областью, мне попалась java-альтернатиа  Jekyll (рубби) в лице проекта &lt;a href=&quot;https://jbake.org/&quot;&gt;JBake&lt;/a&gt;, что как java-разработчику мне показалось ближе.&lt;/p&gt;
&lt;p&gt;Ну что ж, решение принято, стек выбран, - вперёд!&lt;/p&gt;

	</description>
    </item>

  </channel> 
</rss>
