<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JBake</title>
    <link>https://kostenko.org</link>
    <atom:link href="https://kostenko.org/feed.xml" rel="self" type="application/rss+xml" />
    <description>JBake Bootstrap Template</description>
    <language>en-gb</language>
    <pubDate>Пн, 25 мар 2019 12:00:51 +0200</pubDate>
    <lastBuildDate>Пн, 25 мар 2019 12:00:51 +0200</lastBuildDate>

    <item>
      <title>Видео знакомство с Hibernate Search</title>
      <link>https://kostenko.org/blog/2019/03/hibernate-search-intro-video.html</link>
      <pubDate>Ср, 20 мар 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/03/hibernate-search-intro-video.html</guid>
      	<description>
	
Опубликовано мое второе видео на YouTube (о Hibernate Search и интеграции с Wildfly)!

&lt;br/&gt;&lt;br/&gt;
&lt;div class=&quot;row&quot;&gt;
    &lt;iframe align =&quot;center&quot; class=&quot;col-md-offset-3 col-lg-6 col-md-6 col-sm-12 col-xs-12&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/RuGyErfhmL0&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

	</description>
    </item>
    <item>
      <title>SQL хак. Условный COUNT для выражения  SELECT</title>
      <link>https://kostenko.org/blog/2019/03/sql-trick-conditional-count.html</link>
      <pubDate>Сб, 16 мар 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/03/sql-trick-conditional-count.html</guid>
      	<description>
	&lt;p&gt;Для выполнения условной логики в SQL &lt;code&gt;SELECT&lt;/code&gt;, можно использовать выражение &lt;code&gt;CASE&lt;/code&gt;. Следующий SQL хак  позволит вам выполнить условный &lt;code&gt;count()&lt;/code&gt; для вашего запроса.&lt;/p&gt;
&lt;p&gt;Например, чтобы выбрать количество записей с &lt;code&gt;id &amp;gt; 5&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;SQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT SUM(CASE WHEN id &amp;gt; 5 THEN 1 ELSE 0 END) FROM Table
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;JPQL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;entityManager.createQuery(&amp;quot;SELECT SUM(CASE WHEN b.id &amp;gt; 5 THEN 1 ELSE 0 END) FROM BlogEntity b&amp;quot;).getSingleResult()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Criteria API:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery&amp;lt;Number&amp;gt; query = cb.createQuery(Number.class);
Root&amp;lt;BlogEntity&amp;gt; blogEntity = query.from(BlogEntity.class);

query.select(
        cb.sum(
                cb.&amp;lt;Number&amp;gt;selectCase()
                        .when(cb.gt(blogEntity.get(&amp;quot;id&amp;quot;), 5), 1)
                        .otherwise(0)
        )
);

Number result = em.createQuery(query).getSingleResult();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Исходный код, доступен на  &lt;a href=&quot;https://github.com/kostenkoserg/jpa-examples/blob/master/src/test/java/org/kostenko/example/jpa/JpaConditionalCountTest.java&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Как поднять ssh тоннель на Linux</title>
      <link>https://kostenko.org/blog/2019/03/linux-build-ssh-tunnel.html</link>
      <pubDate>Пт, 15 мар 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/03/linux-build-ssh-tunnel.html</guid>
      	<description>
	&lt;p&gt;SSH тоннель позволяет перенаправлять локальный трафик через SSH на удаленный хост. Может быть использован, например, для соедиения с удаленным приложением, которое было запущено на локальном порту удаленного хоста.&lt;/p&gt;
&lt;p&gt;Например, чтобы соединиться с mysql, который был запущен на локальном порту &lt;code&gt;3306&lt;/code&gt; хоста  remotehost.com, вы можете использовать:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ssh -L 3366:localhost:3306 [USERNAME]@remotehost.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;или с использованием  &lt;a href=&quot;https://kostenko.org/blog/2019/02/linux-generate-private-shh-key.html&quot;&gt;SSH keys&lt;/a&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ssh -i [KEY_FILENAME] -L 3366:localhost:3306 [USERNAME]@remotehost.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После этого, вы можете соединиться с базой, используя любимый тулинг на localhost:3366&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Hibernate Search вступление. Развертывание на WildFly.</title>
      <link>https://kostenko.org/blog/2019/02/wildfly-hibernate-search.html</link>
      <pubDate>Чт, 21 фев 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/02/wildfly-hibernate-search.html</guid>
      	<description>
	&lt;p&gt;Hibernate  Search - это мощное решение для реализации возможностей полнотекстового поиска (как google или  amazon) в вашем ЕЕ приложении. Под капотом, для построения индекса, будет использоваться Apache Lucene напрямую, или через Elasticsearch. Hibernate Search может быть легко интегрирован с JPA, Hibernate ORM, Infinispan или другими источниками. Если вы используете Wildfly - вам повезло, - Hibernate Search с ним уже интегрирован.&lt;/p&gt;
&lt;p&gt;Итак, посмотрим, как это работает на практике ...&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.Давайте начнем с gradle проекта, используя hibernate-search и EE зависимости&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;apply plugin: &apos;java&apos;
apply plugin: &apos;war&apos;

sourceCompatibility = &apos;1.8&apos;
defaultTasks &apos;clean&apos;, &apos;build&apos;
ext.libraryVersions = [
    javaee                  : &apos;8.0&apos;,
    wildfly                 : &apos;15.0.1.Final&apos;,
    hibernatesearch         : &apos;5.11.1.Final&apos;,
    hibernateentitymanager  : &apos;5.4.1.Final&apos;,
    h2                      : &apos;1.4.198&apos;,
    dom4j                   : &apos;2.1.1&apos;,
    junit                   : &apos;4.12&apos;
]
configurations {
    wildfly
}
repositories {
    mavenCentral()
}
dependencies {
    wildfly &amp;quot;org.wildfly:wildfly-dist:${libraryVersions.wildfly}@zip&amp;quot;
    providedCompile &amp;quot;javax:javaee-api:${libraryVersions.javaee}&amp;quot;
    providedCompile &amp;quot;org.hibernate:hibernate-search-orm:${libraryVersions.hibernatesearch}&amp;quot;
    testCompile &amp;quot;junit:junit:${libraryVersions.junit}&amp;quot;
    testCompile &amp;quot;com.h2database:h2:${libraryVersions.h2}&amp;quot;
    testCompile &amp;quot;org.hibernate:hibernate-entitymanager:${libraryVersions.hibernateentitymanager}&amp;quot;
    testCompile &amp;quot;org.hibernate:hibernate-search-orm:${libraryVersions.hibernatesearch}&amp;quot;
    testCompile &amp;quot;org.dom4j:dom4j:${libraryVersions.dom4j}&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;**2. Создадим стандартную сущность JPA c Hibernate Search аннотациями **&lt;br /&gt;
&lt;code&gt;src/main/java/org/.../BlogEntity.java:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package org.kostenko.example.wildfly.hibernatesearch;

import javax.persistence.*;
import org.hibernate.search.annotations.*;

@Entity
@Indexed
public class BlogEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column
    @Field(store = Store.YES)
    private String title;

    @Column
    @Field(store = Store.YES)
    private String body;

    // getters, setters
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Основные аннотации Hibernate Search:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;&lt;th&gt;Аннотация    &lt;/th&gt;&lt;th&gt; Описание&lt;/th&gt;&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;@Indexed      &lt;/td&gt;&lt;td&gt; Помечает, какие объекты должны быть индексированы; Позволяет переопределению имя индекса. Только объекты @Indexed могут быть найдены..&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;@Field        &lt;/td&gt;&lt;td&gt; Помечает поле объекта, которое будет индексировано. Существует несколько вариантов работы с индексируемыми полями: &lt;code&gt;store&lt;/code&gt; -  перечислимый тип, указывающий, должно ли значение поля быть сохранено в индексе. По умолчанию - &lt;code&gt;Store.NO&lt;/code&gt; (Значение поля не будет сохранено в индексе.) Хранение значений может быть полезным для использования в механизме Projections,- что позволит восстанавливать значения полей непосредственно из индекса, минуя запросы к СУБД, &lt;code&gt;index&lt;/code&gt; -  перечисление, определяющее, следует ли индексировать поле или нет. По умолчанию - &lt;code&gt;Index.YES&lt;/code&gt; &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;@DocumentId   &lt;/td&gt;&lt;td&gt; Позволяет переопределить идентификатор документа в индексе. По-умолчанию используется поля помеченное JPA-аннотацией @Id. &lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;@SortableField&lt;/td&gt;&lt;td&gt; Помечает что индексируемое поле может быть сортируемым.&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;3. Добавьте свойства hibernate-search в persistence.xml&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;src/test/resources/META-INF/persistence.xml :&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot;?&amp;gt;
&amp;lt;persistence version=&amp;quot;2.0&amp;quot; xmlns=&amp;quot;http://java.sun.com/xml/ns/persistence&amp;quot; xmlns:xsi=&amp;quot;http://www.w3.org/2001/XMLSchema-instance&amp;quot; xsi:schemaLocation=&amp;quot;http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&amp;quot;&amp;gt;
    &amp;lt;persistence-unit name=&amp;quot;myDSTest&amp;quot; transaction-type=&amp;quot;RESOURCE_LOCAL&amp;quot;&amp;gt;
        &amp;lt;provider&amp;gt;org.hibernate.jpa.HibernatePersistenceProvider&amp;lt;/provider&amp;gt;
        &amp;lt;class&amp;gt;org.kostenko.example.wildfly.hibernatesearch.BlogEntity&amp;lt;/class&amp;gt;
        &amp;lt;exclude-unlisted-classes&amp;gt;false&amp;lt;/exclude-unlisted-classes&amp;gt;
        &amp;lt;properties&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.dialect&amp;quot; value=&amp;quot;org.hibernate.dialect.HSQLDialect&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.hbm2ddl.auto&amp;quot; value=&amp;quot;create-drop&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.connection.driver_class&amp;quot; value=&amp;quot;org.hsqldb.jdbcDriver&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.connection.username&amp;quot; value=&amp;quot;sa&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.connection.password&amp;quot; value=&amp;quot;&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.connection.url&amp;quot; value=&amp;quot;jdbc:hsqldb:mem:testdb&amp;quot;/&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.showSql&amp;quot; value=&amp;quot;true&amp;quot;/&amp;gt;
            &amp;lt;!-- Hibernate Search --&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.search.default.directory_provider&amp;quot; value=&amp;quot;filesystem&amp;quot; /&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.search.default.indexBase&amp;quot; value=&amp;quot;/tmp/index1&amp;quot; /&amp;gt;
            &amp;lt;property name=&amp;quot;hibernate.search.default.indexmanager&amp;quot; value=&amp;quot;near-real-time&amp;quot; /&amp;gt;
        &amp;lt;/properties&amp;gt;
    &amp;lt;/persistence-unit&amp;gt;
&amp;lt;/persistence&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как мы могли убедиться, добавить Hibernate Search в свое приложение достаточно легко, - всего пара аннотаций. Теперь Hibernate Search автоматически будет создавать индекс каждый раз, когда объект, будет изменен (создан, удален) через Hibernate ORM. Индекс может быть сохранен в &lt;code&gt;ram&lt;/code&gt; или &lt;code&gt;filesystem&lt;/code&gt;. Другие поставщики, также доступны.&lt;/p&gt;
&lt;p&gt;Итак, пора сделать простой тест и посмотреть, как это работает с &lt;strong&gt;Lucene queries&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;src/test/java/org/.../JpaHibernateSearchTest :&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class JpaHibernateSearchTest {

    private static EntityManager entityManager;
    private static FullTextEntityManager fullTextEntityManager;
    private static QueryBuilder queryBuilder;

    @BeforeClass
    public static void init() {
        entityManager = Persistence.createEntityManagerFactory(&amp;quot;myDSTest&amp;quot;).createEntityManager();
        fullTextEntityManager = Search.getFullTextEntityManager(entityManager);
        queryBuilder = fullTextEntityManager.getSearchFactory().buildQueryBuilder().forEntity(BlogEntity.class).get();
        for (int i = 0; i &amp;lt; 1000; i++) {
            BlogEntity blogEntity = new BlogEntity();
            blogEntity.setTitle(&amp;quot;Title&amp;quot; + i);
            blogEntity.setBody(&amp;quot;BodyBody Body&amp;quot; + i + &amp;quot; look at my horse my horse is a amazing &amp;quot; + i);
            entityManager.getTransaction().begin();
            entityManager.persist(blogEntity);
            entityManager.getTransaction().commit();
        }
        Assert.assertEquals(1000, entityManager.createQuery(&amp;quot;SELECT COUNT(b) FROM BlogEntity b&amp;quot;, Number.class).getSingleResult().intValue());
    }
    /**
     * Keyword Queries - searching for a specific word.
     */
    @Test
    public void shouldSearchByKeywordQuery() throws Exception {
        Query query = queryBuilder.keyword().onFields(&amp;quot;title&amp;quot;, &amp;quot;body&amp;quot;).matching(&amp;quot;Body999&amp;quot;).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class); // wrap Lucene query in a javax.persistence.Query
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();// execute search
        Assert.assertFalse(result.isEmpty());
        Assert.assertEquals(&amp;quot;Title999&amp;quot;, result.get(0).getTitle());
    }
    /**
     * Fuzzy Queries - we can define a limit of “fuzziness”
     */
    @Test
    public void shouldSearchByFuzzyQuery() throws Exception {
        Query query = queryBuilder.keyword().fuzzy().withEditDistanceUpTo(2).withPrefixLength(0).onField(&amp;quot;title&amp;quot;).matching(&amp;quot;TAtle999&amp;quot;).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class);
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();
        Assert.assertFalse(result.isEmpty());
        Assert.assertEquals(&amp;quot;Title999&amp;quot;, result.get(0).getTitle());
    }
    /**
     * Wildcard Queries - queries for which a part of a word is unknown (&apos;?&apos; - single character, &apos;*&apos; - character sequence)
     */
    @Test
    public void shouldSearchByWildcardQuery() throws Exception {
        Query query = queryBuilder.keyword().wildcard().onField(&amp;quot;title&amp;quot;).matching(&amp;quot;?itle*&amp;quot;).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class);
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();
        Assert.assertFalse(result.isEmpty());
        Assert.assertEquals(1000, result.size());
    }
    /**
     * Phrase Queries - search for exact or for approximate sentences
     */
    @Test
    public void shouldSearchByPhraseQuery() throws Exception {
        Query query = queryBuilder.phrase().withSlop(10).onField(&amp;quot;body&amp;quot;).sentence(&amp;quot;look amazing horse 999&amp;quot;).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class);
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();
        Assert.assertFalse(result.isEmpty());
        Assert.assertEquals(&amp;quot;Title999&amp;quot;, result.get(0).getTitle());
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В тесте, мы использовали основные юзкейсы. Но даже этого достаточно, чтобы почувствовать насколько &lt;code&gt;Apache Lucene search engine&lt;/code&gt; неплох. И увидеть, как легко его можно интегрировать с вашим приложением. Обратитесь к &lt;a href=&quot;https://docs.jboss.org/hibernate/stable/search/reference/en-US/html_single/&quot;&gt;официальной документации&lt;/a&gt; для детелей.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Использование Hibernate Search с Wildfly&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Как я уже писал - Hibernate Search интегрирован в  Wildfly начиная с версии 10. Это означает, что эта функциональность активируется автоматически в случае, если вы используете по крайней мере одну ентити с &lt;code&gt;org.hibernate.search.annotations.Indexed&lt;/code&gt;.&lt;br /&gt;
Итак, все что нам нужно, чтобы показать как это работает вместе, - это просто реализовать простой веб-сервис с похожей на юнит тест логикой и запустить его на сервере.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;@Path(&amp;quot;/&amp;quot;)
@Stateless
public class HibernateSearchDemoEndpoint {

    @PersistenceContext
    EntityManager entityManager;

    /**
     * Persist 1000 entities and rebuild index
     * @return
     */
    @GET
    @Path(&amp;quot;/init&amp;quot;)
    @Transactional
    public Response init() {
        int count = entityManager.createQuery(&amp;quot;SELECT COUNT(b) FROM BlogEntity b&amp;quot;, Number.class).getSingleResult().intValue();
        long time = System.currentTimeMillis();
        for (int i = count; i &amp;lt; count + 1000; i++) {
            BlogEntity blogEntity = new BlogEntity();
            blogEntity.setTitle(&amp;quot;Title&amp;quot; + i);
            blogEntity.setBody(&amp;quot;Body Body Body&amp;quot; + i + &amp;quot; look at my horse my horse is a amazing &amp;quot; + i);
            entityManager.persist(blogEntity);
        }
        time = System.currentTimeMillis() - time;
        return Response.ok().entity(String.format(&amp;quot;1000 records persisted. Current records %s Execution time = %s ms.&amp;quot;, count + 1000, time)).build();
    }

    /**
     * Search by index
     * @param q - query string
     * @return
     */
    @GET
    @Path(&amp;quot;/search&amp;quot;)
    public Response search(@QueryParam(&amp;quot;q&amp;quot;) String q) {
        FullTextEntityManager fullTextEntityManager = Search.getFullTextEntityManager(entityManager);
        QueryBuilder queryBuilder = fullTextEntityManager.getSearchFactory().buildQueryBuilder().forEntity(BlogEntity.class).get();
        long time = System.currentTimeMillis();
        Query query = queryBuilder.keyword().onFields(&amp;quot;title&amp;quot;, &amp;quot;body&amp;quot;).matching(q).createQuery();
        javax.persistence.Query persistenceQuery = fullTextEntityManager.createFullTextQuery(query, BlogEntity.class);
        List&amp;lt;BlogEntity&amp;gt; result = persistenceQuery.getResultList();
        time = System.currentTimeMillis() - time;
        String resultStr = result.stream().map(Object::toString).collect(Collectors.joining(&amp;quot;,&amp;quot;));
        return Response.ok().entity( String.format(&amp;quot;Found %s results. [%s] Execution time = %s ms.&amp;quot;,result.size(),resultStr,time)).build();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь, давайте добавим таск в наш &lt;code&gt;build.gradle&lt;/code&gt; для запуска  Wildfly прямо из проекта&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;task removeWildfly(type:Delete) {
    delete &amp;quot;build/wildfly-${libraryVersions.wildfly}&amp;quot;
}
task resolveWildfly(type:Copy, dependsOn:removeWildfly) {
    destinationDir = buildDir
    from {zipTree(configurations.wildfly.singleFile)}
}
task run() {
    dependsOn &apos;resolveWildfly&apos;
    doLast {
        copy {
            from projectDir.toString() + &amp;quot;/build/libs/wildfly-hibernate-search-example.war&amp;quot;
            into projectDir.toString() + &amp;quot;/build/wildfly-${libraryVersions.wildfly}/standalone/deployments&amp;quot;
        }
        exec {
            workingDir = file(projectDir)
            commandLine &amp;quot;./build/wildfly-${libraryVersions.wildfly}/bin/standalone.sh&amp;quot;, &amp;quot;--debug&amp;quot;, &amp;quot;5005&amp;quot;
            ext.output = {
                return standardOutput.toString()
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;run&lt;/code&gt; разархивирует wildfly в каталог проекта, задеплоит приложение и запустит сервер. Итак:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;gradle &amp;amp;&amp;amp; gradle run
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;проверим вывод, чтобы убедиться, что Hiberate создал Index соглсно  пути в  &lt;code&gt;persistence.xml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;...
15:15:37,386 INFO  [org.hibernate.search.store.impl.DirectoryProviderHelper] (MSC service thread 1-3) HSEARCH000041: Index directory not found, creating: &apos;/tmp/index2/org.kostenko.example.wildfly.hibernatesearch.BlogEntity&apos;
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И, наконец, смотрим на результат в браузере&lt;br /&gt;
&lt;img src=&quot;/img/2019-02-hibernate-search-1.png&quot; alt=&quot;create_index&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;/img/2019-02-hibernate-search-2.png&quot; alt=&quot;serach_by_index&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Исходный код проекта, доступен на &lt;a href=&quot;https://github.com/kostenkoserg/wildfly-hibernate-search-example&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Как сгенерировать ssh ключи в Linux</title>
      <link>https://kostenko.org/blog/2019/02/linux-generate-private-shh-key.html</link>
      <pubDate>Ср, 20 фев 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/02/linux-generate-private-shh-key.html</guid>
      	<description>
	&lt;p&gt;Часто, по соображения безопасности или юзабилити, предпочтительнее использовать ssh ключи вместо паролей. Для этого нужно:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Логинимся на удаленный инстанс&lt;/li&gt;
&lt;li&gt;Генерируем ключи&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ssh-keygen -t rsa -f ~/.ssh/[KEY_FILENAME] -C [USERNAME]
cat [KEY_FILENAME].pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Скачиваем приватный ключ  ([KEY_FILENAME]) себе&lt;/li&gt;
&lt;li&gt;Заходим на хост с использованием ключа&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;chmod 400 [KEY_FILENAME]
ssh -i [KEY_FILENAME] [USERNAME]@yourhost.com
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для того, что бы запретить логиниться с паролем и под рутом, отредактируйте  &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;PasswordAuthentication no
PermitRootLogin no
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Затем перезагрузите ssh сервер&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;sudo service ssh restart
&lt;/code&gt;&lt;/pre&gt;

	</description>
    </item>
    <item>
      <title>Моё первое видео</title>
      <link>https://kostenko.org/blog/2019/02/github-jbake-blog-video.html</link>
      <pubDate>Сб, 16 фев 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/02/github-jbake-blog-video.html</guid>
      	<description>
	
Моё первое видео (о том как я делал это блог) на youtube!

&lt;br/&gt;&lt;br/&gt;
&lt;div class=&quot;row&quot;&gt;
    &lt;iframe align =&quot;center&quot; class=&quot;col-md-offset-3 col-lg-6 col-md-6 col-sm-12 col-xs-12&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/_0C2xTa8jsY&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

	</description>
    </item>
    <item>
      <title>Jbake. Добавляем теги, поддержку нескольких языков и аналитику</title>
      <link>https://kostenko.org/blog/2019/01/jbake-blog-improve.html</link>
      <pubDate>Сб, 19 янв 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/01/jbake-blog-improve.html</guid>
      	<description>
	&lt;h4&gt;1. Теги&lt;/h4&gt;
&lt;p&gt;Jbake поддерживает работу с тегами из коробки и при использовании тегов в описании будет генерироваться отдельная страница под каждый тег. Достаточно отредактировать параметр &lt;code&gt;render.tags&lt;/code&gt; в конфигурационном файле &lt;code&gt;jbake.properties&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;render.tags=true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь в зависимости от того, где мы хотим разместить список тегов, редактируем соответствующий темплейт. Для этого блога я использую freemarker и решил вывести теги в меню в виде выпадающего списка. Соответственно, изменив  ``menu.ftl`, как показано ниже:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;ul class=&amp;quot;dropdown-menu&amp;quot;&amp;gt;
      &amp;lt;#list tags as tag&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;${content.rootpath}${tag.uri}&amp;quot;&amp;gt;${tag.name}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;/#list&amp;gt;
  &amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Готово!&lt;/p&gt;
&lt;h4&gt;2. Контент на нескольких языках&lt;/h4&gt;
&lt;p&gt;К сожалению, Jbake пока не поддерживает мультиязычные блоги на уровне метаданных и для обеспечения этой функциональности мне пришлость проделать несколько нехитрых упражнений. Сперва, я просто хотел сделать полную копию с другим языком контента, но в случае любых изменений для шаблонов, скриптов, изображений - правки пришлось бы делать дважды. Что не есть хорошо.&lt;/p&gt;
&lt;p&gt;Вместо этого я просто создал каталог &lt;code&gt;content_ru&lt;/code&gt; в корне проекта.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;├── assets  
├── content  
├── content_ru
├── templates
├── jbake.properties
├── README.md  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;К счастью, в &lt;code&gt;jbake.properies&lt;/code&gt; есть возможность установить каталог контента, который будет использован при генерации, что позволяет держать несколько директорий в проекте.  Теперь сгенерировать мультиязычный блог можно используя скрипт:&lt;/p&gt;
&lt;p&gt;bakeblog.sh:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash

# Helper script to bake the blog
# Author: kostenko

export PATH=&amp;quot;/opt/jbake-2.6.3-bin/bin&amp;quot;:$PATH
rm -R ./output
# Building en version
export JBAKE_OPTS=&amp;quot;-Duser.language=EN&amp;quot;
jbake -b
# Build ru version
export JBAKE_OPTS=&amp;quot;-Duser.language=RU&amp;quot;
mv jbake.properties jbake.properties.orig
cat jbake.properties.orig &amp;gt;&amp;gt; jbake.properties
echo &amp;quot;content.folder=content_ru&amp;quot; &amp;gt;&amp;gt; jbake.properties
jbake -b . output/ru
# cleanup
rm jbake.properties
mv jbake.properties.orig jbake.properties
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Добавим возможность переключения языков в меню:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- switch language --&amp;gt;
&amp;lt;ul class=&amp;quot;nav navbar-nav navbar-right&amp;quot;&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/&amp;quot;&amp;gt;en&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;/ru&amp;quot;&amp;gt;ru&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;На этом все!&lt;/p&gt;
&lt;h4&gt;3. Аналитика&lt;/h4&gt;
&lt;p&gt;Для того что бы подключить &lt;a href=&quot;https://analytics.google.com&quot;&gt;Google analytics&lt;/a&gt; нужно выполнить несколько простых шагов&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Зарегестировать ресурс в GA&lt;/li&gt;
&lt;li&gt;Получить сгенерированный GA фрагмент кода&lt;/li&gt;
&lt;li&gt;Вставить этот код в &lt;code&gt;header.ftl&lt;/code&gt; первой строкой блока &lt;code&gt;&amp;lt;HEAD&amp;gt;&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!-- Global site tag (gtag.js) - Google Analytics --&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;script async src=&amp;quot;https://www.googletagmanager.com/gtag/js?id=&amp;lt;YOUR_GA_ID&amp;gt;&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script&amp;gt;
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag(&apos;js&apos;, new Date());
    gtag(&apos;config&apos;, &apos;&amp;lt;YOUR_GA_ID&amp;gt;&apos;);
  &amp;lt;/script&amp;gt;
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;P.S. При желании к блогу можно подключить возможность оставлять комментарии, используя например &lt;a href=&quot;https://disqus.com/&quot;&gt;Disqus&lt;/a&gt;.&lt;br /&gt;
P.P.S. Код этого блога доступен на &lt;a href=&quot;https://github.com/kostenkoserg/kostenko.blog.src&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Как поднять блог на github и jbake</title>
      <link>https://kostenko.org/blog/2019/01/github-jbake-blog.html</link>
      <pubDate>Пт, 18 янв 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/01/github-jbake-blog.html</guid>
      	<description>
	&lt;p&gt;Развернуть свой персональный блог, блог компании или лендинг проекта используя &lt;a href=&quot;https://pages.github.com/&quot;&gt;github&lt;/a&gt; - задача, как оказалось, несложная и не требующая особых навыков. Здесь я, максимально конструктивно, постараюсь изложить основные шаги, которые необходимо сделать для того, что бы обзавестись личным блогом на небезизвестном ресурсе.&lt;/p&gt;
&lt;h4&gt;Шаг 1. Хостим статику на github&lt;/h4&gt;
&lt;p&gt;Для этого нам потребуются аккаунт на &lt;a href=&quot;https://github.com/&quot;&gt;github&lt;/a&gt; и базовые навыки работы с &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;. К слову сказать, все ниже изложенное можно проделать и для конкурирующего сервиса &lt;a href=&quot;https://gitlab.com/&quot;&gt;gitlab&lt;/a&gt;, - где кому больше нравится.&lt;/p&gt;
&lt;p&gt;Далее, нужно просто создать проект, назвав его:  &amp;lt;логин&amp;gt;.github.io, например kostenkoserg.github.io&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/ru/img/my_github_srcshot.png&quot; alt=&quot;github pages project screenshot&quot; /&gt;&lt;/p&gt;
&lt;p&gt;В принципе, на этом вся подготовительная рабобта для хостинга статики и завершена. Теперь клонируем проект себе (пока пустой), создаём index.html и пушим в репозиторий:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ git clone https://github.com/kostenkoserg/kostenkoserg.github.io.git
$ cd kostenkoserg.github.io
$ echo &amp;quot;Hello World!&amp;quot;
$ git commit -m &amp;quot;my first github page&amp;quot;
$ git push
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Все! Страничка доступна по &lt;a href=&quot;https://kostenkoserg.github.io&quot;&gt;https://kostenkoserg.github.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/ru/img/first_github_page.png&quot; alt=&quot;first_github_page&quot; /&gt;&lt;br /&gt;
По желанию, к сайту можно подвязать уже существующий домен, если по каким-либо соображениям .github.io не подходит. Для этого нужно&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Добавить &lt;code&gt;A&lt;/code&gt; записи в настройках DNS провайдера с GitHub ипишниками&lt;/li&gt;
&lt;li&gt;В настройках проекта на  GitHub указать DNS имя&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Шаг 2. Генерация статического сайта с помощью Jbake&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://jbake.org/&quot;&gt;Jbake&lt;/a&gt; - это проект, с открытым исходным кодом, для генерации статических сайтов. Для Jbake доступна интеграция с  Gradle и Maven, из коробки поддержка Bootstrap и прозрачная интеграция с другими CSS фреймворками, а так же поддержка Freemarker, Groovy, Thymeleaf и Jade в качестве шаблонов.&lt;/p&gt;
&lt;p&gt;Для начала работы с Jbake, качаем дистрибутив с &lt;a href=&quot;https://jbake.org/download.html&quot;&gt;сайта проекта&lt;/a&gt; и распаковываем архив куда-то себе. После чего генерируем структуру своего сайта:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ cd myblog
$ /opt/jbake/bin/jbake -i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В результате получаем следующую структуру каталогов и немного тестового контента:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;├── assets
│   ├── css
│   │   ├── asciidoctor.css
│   │   ├── base.css
│   │   ├── bootstrap.min.css
│   │   └── prettify.css
│   ├── favicon.ico
│   ├── fonts
│   │   ├── ...
│   └── js
│       ├── bootstrap.min.js
│       ├── html5shiv.min.js
│       ├── jquery-1.11.1.min.js
│       └── prettify.js
├── content
│   ├── about.html
│   └── blog
│       └── 2013
│           ├── first-post.html
│           ├── second-post.md
│           └── third-post.adoc
├── jbake.properties
└── templates
    ├── archive.ftl
    ├── feed.ftl
    ├── footer.ftl
    ├── header.ftl
    ├── index.ftl
    ├── menu.ftl
    ├── page.ftl
    ├── post.ftl
    ├── sitemap.ftl
    └── tags.ftl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь генерируем сам сайт:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/opt/jbake/bin/jbake -b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В результате чего получим каталог &lt;code&gt;output&lt;/code&gt; с нашим статическим сайтом.&lt;br /&gt;
Проверить, что получилось можно по &lt;a href=&quot;http://localhost:8820/&quot;&gt;http://localhost:8820/&lt;/a&gt;, запустив всторенный сервер&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;/opt/jbake/bin/jbake -s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/ru/img/jbake_default_site.png&quot; alt=&quot;jbake_default_site&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Всё! наш статический сайт готов! Для полноценного ведения блога, теперь достаточно отредактировать содержимое каталога &lt;code&gt;content&lt;/code&gt;, перегенерировать сайт и запушить полученный &lt;code&gt;output&lt;/code&gt; в, созданный на первом шаге, github репозиторий.&lt;/p&gt;
&lt;p&gt;Jbake поддерживает несколько форматов контента: HTML, Markdown, AsciiDoc, - что позволяет вести свой сайт, используя любой текстовый редактор. Я использую &lt;a href=&quot;https://atom.io/&quot;&gt;Atom&lt;/a&gt; и &lt;a href=&quot;https://www.markdownguide.org/basic-syntax/&quot;&gt;Markdown&lt;/a&gt;.&lt;/p&gt;

	</description>
    </item>
    <item>
      <title>Первая запись в блоге</title>
      <link>https://kostenko.org/blog/2019/01/start-blogging.html</link>
      <pubDate>Чт, 17 янв 2019 00:00:00 +0200</pubDate>
      <guid isPermaLink="false">blog/2019/01/start-blogging.html</guid>
      	<description>
	&lt;p&gt;Мысли о собственном блоге посещали меня уже давно и достаточно регулярно, но в силу различных причин реализация задуманного откладывалась. Среди причин было и желание реализовать собственный движок для блогов (зачем-то), и поиск подходящих стилей (ведь так важно), и знакомство со специализированными решениями: wordpress, wix, blogger и другими...&lt;/p&gt;
&lt;p&gt;В итоге, в качестве платформы был выбран &lt;a href=&quot;https://pages.github.com/&quot;&gt;pages.github.io&lt;/a&gt; с его генератором статического контента &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;. Последнее показалось мне самым сбалансированным решеним: понятно, бесплантно,  быстро, надежно. Да и найти лучшее место для технического блога сегодня, наверное, трудно. По мере знакомства с  предметной областью, мне попалась java-альтернатиа  Jekyll (рубби) в лице проекта &lt;a href=&quot;https://jbake.org/&quot;&gt;JBake&lt;/a&gt;, что как java-разработчику мне показалось ближе.&lt;/p&gt;
&lt;p&gt;Ну что ж, решение принято, стек выбран, - вперёд!&lt;/p&gt;

	</description>
    </item>

  </channel> 
</rss>
